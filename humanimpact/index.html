<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sorting Game - Human Impact</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    /* ----------  CORE LAYOUT  ---------- */
    :root {
      /* Light Blue/Coral color palette */
      --bg: #a7d7c5;
      --panel: #F4E4C6;
      --btn: #f7a072;
      --btn-hover: #f4845f;
      /* Variables for item styling */
      --label-bg: #eee8d5;
      --label-border: #93a1a1;
      --target-border: #93a1a1;
      --correct-bg: #dff0d8;
      --correct-border: #22c55e; /* Use checkmark green */
    }
    *{box-sizing:border-box;}
    body{
      margin:0; font-family:'Poppins',sans-serif; background:var(--bg);
      display:flex; flex-direction:column; align-items:center; padding:20px;
      overscroll-behavior: none;
    }
    h1{font-size:2.5rem;color:#fff;margin:5px 0; text-shadow: 1px 1px 2px rgba(0,0,0,0.1);}
    p{color:#fff;margin:0 0 20px;}

    .game-container{
      background:var(--panel); width:100%; max-width:800px; padding:20px; border-radius:10px;
      position: relative;
    }

    /* ----------  DRAG ITEMS (TEXT BOXES + EMOJI) ---------- */
    #items{ /* Changed ID */
        display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin-bottom:20px;
        min-height: 80px; /* Adjust min height as needed */
        padding: 10px;
        background-color: #fff; /* White background for pool */
        border-radius: 8px;
        border: 2px dashed var(--label-border);
    }
    /* Updated item styling for text + emoji */
    .item {
      /* Remove fixed dimensions */
      /* Use padding for size */
      padding: 8px 12px;
      background-color: var(--label-bg, #eee8d5); /* Use variable or default */
      border: 1px solid var(--label-border, #93a1a1);
      border-radius: 6px;
      cursor: grab;
      font-weight: normal;
      color: #586e75;
      touch-action: none;
      user-select: none;
      position: relative; /* Needed for absolute positioning on drag */
      transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, opacity 0.2s ease-out, background-color 0.2s, border-color 0.2s;
      /* Use flex to align emoji and text nicely */
      display: inline-flex; /* Let width fit content */
      align-items: center;
      gap: 6px; /* Space between emoji and text */
      text-align: left; /* Align text left */
      max-width: 200px; /* Prevent extremely long items if needed */
    }
     /* Span specifically for native emoji characters */
    .item-emoji {
        font-size: 1.2em; /* Make emoji slightly larger than text */
        line-height: 1; /* Prevent extra line height */
        /* Prevent emoji interfering with drag */
        pointer-events: none;
        user-select: none;
    }
     .item-text {
        /* Prevent text interfering with drag */
        pointer-events: none;
        user-select: none;
        line-height: 1.2; /* Adjust line height for readability */
        flex-shrink: 1; /* Allow text to wrap if needed */
     }

    /* Dragging styles */
    .item.dragging { opacity: 0.7; cursor: grabbing; position: absolute; z-index: 1000; box-shadow: 0 5px 15px rgba(0,0,0,0.2); transform: scale(1.05); transition: none; background-color: var(--panel); }
    .item.native-dragging { opacity: 0.3; }


    /* ----------  DROP ZONES  ---------- */
    .zones{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:20px;}
    .zone-label{font-weight:bold;margin-bottom:5px;color:#333;}
    .drop-zone{
        width:100%;min-height:150px;background:#fff;border:2px dashed var(--target-border);border-radius:8px;
        padding:10px;display:flex;flex-wrap:wrap;gap:10px; /* Gap between dropped items */
        align-content: flex-start; /* Align items to the top */
        transition:background .3s, border-style .3s;
    }
    .drop-zone.over{background:#e0e0e0; border-style: solid;}
    /* Style for items dropped correctly in zones */
     .drop-zone .item {
         cursor: default;
         background-color: var(--correct-bg, #dff0d8);
         border: 1px solid var(--correct-border, #859900);
         box-shadow: none;
         margin: 0; /* Remove extra margin when dropped */
         /* Overrides for placed item */
         position: static !important; /* Override dragging position */
         transform: none !important; /* Override dragging scale */
         opacity: 1 !important; /* Override dragging opacity */
     }

    /* ----------  CONTROLS  ---------- */
    .controls{text-align:center;}
    .controls button{ background:var(--btn);color:#fff;border:none;padding:10px 20px;border-radius:10px;cursor:pointer; margin:10px 5px;font-size:1.2rem;font-family:'Poppins',sans-serif;transition:background .3s; }
    .controls button:hover{background:var(--btn-hover);}
  </style>
</head>
<body>
  <h1>Human Impact</h1>
  <p>Does the action help or hurt plants and animals? Drag the description to the correct category.</p>

  <div class="game-container">
    <div id="items">
        </div>

    <div class="zones">
      <div class="zone">
        <div class="zone-label">Helps Plants & Animals</div>
        <div id="positive" class="drop-zone" aria-label="Positive human impact drop zone"></div>
      </div>
      <div class="zone">
        <div class="zone-label">Hurts Plants & Animals</div>
        <div id="negative" class="drop-zone" aria-label="Negative human impact drop zone"></div>
      </div>
    </div>

    <div class="controls">
      <button id="check-btn" type="button">Check Answers</button>
      <button id="reset-btn" type="button">Reset</button>
    </div>
  </div>

  <script>
  /**
   * Sorting Game - Human Impact (Positive vs Negative)
   * v3 - Uses text boxes with emojis as draggable items
   */
  document.addEventListener('DOMContentLoaded', () => {
    // No longer need OpenMoji function if using native emojis
    // const om = code => `https://...`;

    // --- UPDATED ITEMS with Labels and Emojis ---
    // No ICONS object needed
    const ITEMS = [
      // Positive Actions
      {key:'recycling', category:'positive', label:'Recycling', emoji:'â™»ï¸'},
      {key:'planting',  category:'positive', label:'Planting Trees', emoji:'ðŸŒ³'},
      {key:'park',      category:'positive', label:'Protecting Parks', emoji:'ðŸžï¸'},
      {key:'reusing',   category:'positive', label:'Reusing Bags/Items', emoji:'ðŸ›ï¸'},
      {key:'protect',   category:'positive', label:'Protecting Wildlife', emoji:'ðŸ›¡ï¸'},
      // Negative Actions
      {key:'litter',    category:'negative', label:'Littering', emoji:'ðŸ—‘ï¸'},
      {key:'factory',   category:'negative', label:'Factory Pollution', emoji:'ðŸ­'},
      {key:'wood',      category:'negative', label:'Cutting Trees', emoji:'ðŸªµ'},
      {key:'invasive',  category:'negative', label:'Invasive Species', emoji:'ðŸ›'},
      {key:'exhaust',   category:'negative', label:'Car Pollution', emoji:'ðŸš—'}
     ];
    // --- End of UPDATED ITEMS ---

    const itemsPool = document.getElementById('items'); // Correct ID for the pool
    const dropZones = document.querySelectorAll('.drop-zone');
    const gameContainer = document.querySelector('.game-container');

    // State variables (unchanged)
    let pointerDraggedItem = null; // Stores the actual element being dragged
    let offsetX = 0;
    let offsetY = 0;
    let currentOverZone = null;
    let isTouchDragging = false;

    // --- UPDATED Initialization Function ---
    function initializeGame() {
        if (!itemsPool) {
            console.error("Element with ID 'items' not found!");
            return;
        }
        itemsPool.innerHTML = ''; // Clear the pool

        dropZones.forEach(zone => { zone.innerHTML = ''; zone.classList.remove('over'); });
        // Shuffle items before creating elements
        const shuffledItems = [...ITEMS].sort(() => Math.random() - 0.5);

        shuffledItems.forEach((item, idx) => {
            const card = document.createElement('div');
            card.className = 'item';
            card.draggable = true;
            card.id = `item-${idx}`;
            card.dataset.category = item.category; // Assigns 'positive' or 'negative'

            // --- Create inner HTML with emoji and text label ---
            const emojiChar = item.emoji;
            const labelText = item.label;
            card.innerHTML = `
                <span class="item-emoji" role="img" aria-label="${labelText}">${emojiChar}</span>
                <span class="item-text">${labelText}</span>
            `;
            // --- End of inner HTML creation ---

            card.addEventListener('dragstart', handleDragStartMouse);
            card.addEventListener('dragend', handleDragEndMouse);
            card.addEventListener('pointerdown', handlePointerDown);
            itemsPool.appendChild(card); // Append to the correct container
        });
        pointerDraggedItem = null;
        isTouchDragging = false;
        currentOverZone = null;
    }
    // --- End of UPDATED Initialization ---

    // --- Event Handlers (Mouse D&D, Pointer Events) ---
    // Most logic remains identical, handling the .item element
    // --- Standard Mouse D&D Handlers ---
    function handleDragStartMouse(e) {
        if (e.pointerType !== 'touch') {
            // Pass the element's ID for lookup on drop
            e.dataTransfer.setData('text/plain', e.currentTarget.id);
            e.dataTransfer.effectAllowed = 'move';
            // pointerDraggedItem = e.currentTarget; // Track element for potential use
            setTimeout(() => { e.target.classList.add('native-dragging'); }, 0);
            isTouchDragging = false;
        } else {
            e.preventDefault(); // Prevent default browser drag for touch
        }
    }
    function handleDragEndMouse(e) {
        if (e.pointerType !== 'touch') {
            e.target.classList.remove('native-dragging');
             // Ensure highlights are cleared if drag ends unexpectedly
            dropZones.forEach(zone => zone.classList.remove('over'));
        }
         // General cleanup, reset state vars
        isTouchDragging = false;
        pointerDraggedItem = null;
        currentOverZone = null;
        document.body.style.userSelect = '';
    }
    dropZones.forEach(zone => {
        zone.addEventListener('dragover', handleDragOverMouse);
        zone.addEventListener('dragleave', handleDragLeaveMouse);
        zone.addEventListener('drop', handleDropMouse);
    });
    function handleDragOverMouse(e) {
        e.preventDefault();
        // Add hover effect only if the target isn't the one being dragged from (if applicable)
        e.currentTarget.classList.add('over');
        if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
    }
    function handleDragLeaveMouse(e) {
         // Check relatedTarget to prevent flickering when moving over child elements (the dropped items)
        if (!e.currentTarget.contains(e.relatedTarget)) {
           e.currentTarget.classList.remove('over');
        }
    }
    function handleDropMouse(e) {
        e.preventDefault();
        if (e.pointerType !== 'touch') { // Only handle mouse drops here
            const droppedItemId = e.dataTransfer.getData('text/plain');
            const droppedElement = document.getElementById(droppedItemId);
            const targetZone = e.currentTarget;

            if (droppedElement && targetZone.classList.contains('drop-zone')) {
                 // Check if the category matches (optional immediate feedback or rely on check button)
                 // const isCorrect = droppedElement.dataset.category === targetZone.id;

                 // Append the element
                 targetZone.appendChild(droppedElement);
                 // Optionally style immediately, or wait for check button
                 // droppedElement.style.borderColor = isCorrect ? 'green' : 'red';
            }
            if(droppedElement) droppedElement.classList.remove('native-dragging');
            targetZone.classList.remove('over');
            currentOverZone = null;
        }
    }
    // --- Pointer Event Handlers ---
    function handlePointerDown(e) {
        if (e.button !== 0 || pointerDraggedItem) return; // Primary button only, no drag yet
        pointerDraggedItem = e.currentTarget; // Store the element itself
        isTouchDragging = e.pointerType === 'touch';

        if (isTouchDragging) {
            e.preventDefault();
            pointerDraggedItem.setPointerCapture(e.pointerId);
            const rect = pointerDraggedItem.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;
            // Apply dragging style AFTER getting rect, before moving
            pointerDraggedItem.classList.add('dragging');
             // Position immediately
             handlePointerMove(e);
        } else {
            // For mouse, allow native dragstart, but capture for move/up
            try { pointerDraggedItem.setPointerCapture(e.pointerId); } catch (err) {}
        }
        document.addEventListener('pointermove', handlePointerMove);
        document.addEventListener('pointerup', handlePointerUp);
        document.addEventListener('pointercancel', handlePointerUp);
        document.body.style.userSelect = 'none';
    }
    function handlePointerMove(e) {
        if (!pointerDraggedItem || !pointerDraggedItem.hasPointerCapture(e.pointerId)) return;

        if (isTouchDragging) {
            e.preventDefault(); // Prevent scrolling during touch drag
            const gameRect = gameContainer.getBoundingClientRect();
            let newX = e.clientX - gameRect.left - offsetX;
            let newY = e.clientY - gameRect.top - offsetY;
            pointerDraggedItem.style.left = `${newX}px`;
            pointerDraggedItem.style.top = `${newY}px`;
        }

        // --- Drop Zone Highlighting (Both) ---
        let elementUnderPointer = null;
        const originalVisibility = isTouchDragging ? pointerDraggedItem.style.visibility : '';
        // Temporarily hide only for touch drag check
        if (isTouchDragging) { pointerDraggedItem.style.visibility = 'hidden'; }

        elementUnderPointer = document.elementFromPoint(e.clientX, e.clientY);

        if (isTouchDragging) { pointerDraggedItem.style.visibility = originalVisibility; }

        let dropTarget = elementUnderPointer ? elementUnderPointer.closest('.drop-zone') : null;

        if (currentOverZone && currentOverZone !== dropTarget) {
            currentOverZone.classList.remove('over');
        }
        if (dropTarget) {
            dropTarget.classList.add('over');
            currentOverZone = dropTarget;
        } else {
            currentOverZone = null;
        }
    }
    function handlePointerUp(e) {
        if (!pointerDraggedItem || !pointerDraggedItem.hasPointerCapture(e.pointerId)) {
            // Cleanup listeners if state is inconsistent
            document.removeEventListener('pointermove', handlePointerMove);
            document.removeEventListener('pointerup', handlePointerUp);
            document.removeEventListener('pointercancel', handlePointerUp);
            document.body.style.userSelect = '';
            return;
        }

        document.removeEventListener('pointermove', handlePointerMove);
        document.removeEventListener('pointerup', handlePointerUp);
        document.removeEventListener('pointercancel', handlePointerUp);
        document.body.style.userSelect = '';

        // --- Touch Drop Logic ---
        if (isTouchDragging) {
            pointerDraggedItem.classList.remove('dragging'); // Reset style first
            pointerDraggedItem.style.left = '';
            pointerDraggedItem.style.top = '';
            pointerDraggedItem.style.visibility = '';

            if (currentOverZone) { // Dropped onto a potential zone
                 // Append the actual dragged element
                currentOverZone.appendChild(pointerDraggedItem);
                currentOverZone.classList.remove('over');
            } else { // Dropped outside zones, return to pool
                itemsPool.appendChild(pointerDraggedItem);
            }
        }
        // --- Mouse Up Logic ---
        else {
             // Native drop handler deals with placement. Just remove hover from potential zone.
             pointerDraggedItem.classList.remove('native-dragging');
            if (currentOverZone) {
                currentOverZone.classList.remove('over');
            }
        }

        // Common cleanup
        try { pointerDraggedItem.releasePointerCapture(e.pointerId); } catch(err) {}
        pointerDraggedItem = null;
        isTouchDragging = false;
        currentOverZone = null;
        offsetX = 0;
        offsetY = 0;
    }


    // --- Control Button Listeners ---
    document.getElementById('check-btn').addEventListener('click', () => {
        let allCorrect = true;
        const zoneIds = ['positive', 'negative'];
        zoneIds.forEach(zoneId => {
            const zone = document.getElementById(zoneId);
            Array.from(zone.children).forEach(item => {
                if (item.classList.contains('item')) {
                    const isCorrect = item.dataset.category === zoneId;
                    item.style.border = isCorrect ? '3px solid #22c55e' : '3px solid #ef4444'; // Use border for feedback
                     // Reset background/border from potential earlier checks
                    // item.style.backgroundColor = '';
                    // item.style.borderColor = isCorrect ? 'var(--correct-border)' : 'red';
                    if (!isCorrect) allCorrect = false;
                }
            });
        });
       // Check items remaining in the top container
       Array.from(itemsPool.children).forEach(item => {
           if (item.classList.contains('item')) {
               item.style.border = '3px solid #f97316'; // Mark as unplaced
               allCorrect = false;
           }
       });
       if(allCorrect && itemsPool.children.length === 0) {
         console.log("All items placed correctly!");
       }
    });
    document.getElementById('reset-btn').addEventListener('click', () => {
         // Clear borders before re-initializing
         document.querySelectorAll('.item').forEach(item => item.style.border = '');
        initializeGame();
    });

    // --- Initial Game Setup ---
    initializeGame();

  });
  </script>
</body>
</html>
