<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sorting Game – OpenMoji Edition</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    /* ----------  CORE LAYOUT  ---------- */
    :root {
      --bg: #6F83A1;
      --panel: #F4E4C6;
      --btn: #f472b6;
      --btn-hover: #ec4899;
    }
    *{box-sizing:border-box;}
    body{
      margin:0; font-family:'Poppins',sans-serif; background:var(--bg);
      display:flex; flex-direction:column; align-items:center; padding:20px;
      /* Prevent scrolling bounce effect on touch devices during drag */
      overscroll-behavior: none;
    }
    h1{font-size:2.5rem;color:#fff;margin:5px 0;}
    p{color:#fff;margin:0 0 20px;}

    .game-container{
      background:var(--panel); width:100%; max-width:800px; padding:20px; border-radius:10px;
      position: relative; /* Needed for absolute positioning of JS-dragged item */
    }

    /* ----------  DRAG ITEMS  ---------- */
    #items{display:flex;flex-wrap:wrap;gap:15px;justify-content:center;margin-bottom:20px; min-height: 100px; /* Ensure space */}
    .item{
      width:80px;height:80px;background:#fff;display:flex;align-items:center;justify-content:center;
      border-radius:8px;box-shadow:0 2px 5px rgba(0,0,0,0.1);cursor:grab;
      touch-action: none; /* Crucial for preventing default touch actions like scrolling */
      user-select: none; /* Prevent text selection during drag */
      position: relative; /* Default position */
      transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, opacity 0.2s ease-out; /* Smooth transition back */
    }
    .item img {
      pointer-events: none; /* Make sure the image doesn't interfere with pointer events */
      max-width: 50%;
      max-height: 50%;
      user-select: none;
    }
    /* Class for VISUAL JS DRAGGING (Touch) */
    .item.dragging {
      opacity: 0.7;
      cursor: grabbing;
      position: absolute; /* Take out of flow for JS positioning */
      z-index: 1000;
      box-shadow: 0 10px 20px rgba(0,0,0,0.2);
      transform: scale(1.1);
      transition: none; /* No transition during active drag */
    }
    /* Class for HIDING ORIGINAL during NATIVE MOUSE DRAG */
    .item.native-dragging {
        opacity: 0.3; /* Make original faint while browser shows ghost */
        /* transition is useful here for smooth fade */
    }


    /* ----------  DROP ZONES  ---------- */
    .zones{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:20px;}
    .zone-label{font-weight:bold;margin-bottom:5px;color:#333;}
    .drop-zone{
      width:100%;min-height:150px;background:#fff;border:2px dashed #ccc;border-radius:8px;
      padding:10px;display:flex;flex-wrap:wrap;gap:10px;transition:background .3s, border-style .3s;
    }
    .drop-zone.over{background:#e0e0e0; border-style: solid;} /* Highlight for both mouse and touch hover */

    /* ----------  CONTROLS  ---------- */
    .controls{text-align:center;}
    .controls button{
      background:var(--btn);color:#fff;border:none;padding:10px 20px;border-radius:10px;cursor:pointer;
      margin:10px 5px;font-size:1.2rem;font-family:'Poppins',sans-serif;transition:background .3s;
    }
    .controls button:hover{background:var(--btn-hover);}
  </style>
</head>
<body>
  <h1>Natural or Processed</h1>
  <p>Drag and drop each icon into the correct category</p>

  <div class="game-container">
    <div id="items"></div>

    <div class="zones">
      <div class="zone">
        <div class="zone-label">Natural</div>
        <div id="natural" class="drop-zone" aria-label="Natural items drop-zone"></div>
      </div>
      <div class="zone">
        <div class="zone-label">Processed</div>
        <div id="processed" class="drop-zone" aria-label="Processed items drop-zone"></div>
      </div>
    </div>

    <div class="controls">
      <button id="check-btn" type="button">Check Answers</button>
      <button id="reset-btn" type="button">Reset</button>
    </div>
  </div>

  <script>
  /**
   * Sorting Game – OpenMoji Icons
   * Enhanced with pointer events for touch support alongside standard D&D for mouse.
   * Fix: Separate visual handling for mouse (native ghost) and touch (JS positioning)
   * to prevent mouse jumpiness. Use pointermove for hover detection on both.
   */
  document.addEventListener('DOMContentLoaded', () => {
    const om = code => `https://cdn.jsdelivr.net/npm/openmoji@14.0.0/color/svg/${code}.svg`;
    const ICONS = {
      leaf:`<img src="${om('1F331')}" alt="leaf">`,
      dunes:`<img src="${om('1F3DC')}" alt="desert dunes">`,
      forest:`<img src="${om('1F332')}" alt="evergreen tree">`,
      rock:`<img src="${om('1FAA8')}" alt="rock">`,
      shells:`<img src="${om('1F41A')}" alt="spiral shell">`,
      starfish:`<img src="${om('1F31F')}" alt="starfish">`,
      docs:`<img src="${om('1F4C4')}" alt="document">`,
      desk:`<img src="${om('1FA91')}" alt="chair proxy">`,
      playground:`<img src="${om('1F6DD')}" alt="playground slide">`,
      beam:`<img src="${om('1F6A7')}" alt="barrier">`,
      brick:`<img src="${om('1F9F1')}" alt="brick">`,
      bottles:`<img src="${om('1F37E')}" alt="bottle">`,
      blocks:`<img src="${om('1F3B2')}" alt="blocks">`
     };
    const ITEMS = [
      {key:'leaf',category:'natural'},{key:'dunes',category:'natural'},{key:'forest',category:'natural'},
      {key:'rock',category:'natural'},{key:'shells',category:'natural'},{key:'starfish',category:'natural'},
      {key:'docs',category:'processed'},{key:'desk',category:'processed'},{key:'playground',category:'processed'},
      {key:'beam',category:'processed'},{key:'brick',category:'processed'},{key:'bottles',category:'processed'},
      {key:'blocks',category:'processed'}
     ];
    const itemsContainer = document.getElementById('items');
    const dropZones = document.querySelectorAll('.drop-zone');
    const gameContainer = document.querySelector('.game-container');

    // --- State variables ---
    let pointerDraggedItem = null; // The element being interacted with via pointer events
    let offsetX = 0;
    let offsetY = 0;
    let currentOverZone = null; // Track zone hover via pointermove
    let isTouchDragging = false; // Flag to differentiate touch/mouse handling in pointer events

    // --- Initialization ---
    function initializeGame() {
        itemsContainer.innerHTML = '';
        dropZones.forEach(zone => { zone.innerHTML = ''; zone.classList.remove('over'); });
        ITEMS.sort(() => Math.random() - 0.5).forEach((item, idx) => {
            const card = document.createElement('div');
            card.className = 'item';
            card.draggable = true; // Enable native drag for mouse
            card.id = `item-${idx}`;
            card.dataset.category = item.category;
            card.innerHTML = ICONS[item.key];
            // Add ALL listeners
            card.addEventListener('dragstart', handleDragStartMouse);
            card.addEventListener('dragend', handleDragEndMouse); // Add dragend listener
            card.addEventListener('pointerdown', handlePointerDown);
            itemsContainer.appendChild(card);
        });
         // Reset state just in case
        pointerDraggedItem = null;
        isTouchDragging = false;
        currentOverZone = null;
    }

    // --- Standard Mouse D&D Handlers ---
    function handleDragStartMouse(e) {
      // This event typically only fires for mouse drags triggered by `draggable=true`
      if (e.pointerType !== 'touch') {
          e.dataTransfer.setData('text/plain', e.currentTarget.id);
          e.dataTransfer.effectAllowed = 'move';
          // Add class to hide original slightly ONLY for mouse drag
          // Use setTimeout to ensure it applies after dragstart initializes browser ghost
          setTimeout(() => {
              e.target.classList.add('native-dragging');
          }, 0);
          isTouchDragging = false; // Ensure flag is false for mouse drag
      } else {
           // Should not happen if pointerdown logic is correct, but prevent default just in case
           e.preventDefault();
      }
    }

    // Add handler for dragend to clean up the class and state
    function handleDragEndMouse(e) {
        // This fires when a native drag operation ends (drop, cancel, escape)
        if (e.pointerType !== 'touch') {
            e.target.classList.remove('native-dragging');
            // Also ensure drop zones hover state is cleared if drag ends unexpectedly
             dropZones.forEach(zone => zone.classList.remove('over'));
        }
         // Reset potentially lingering state if pointerup didn't catch it
        isTouchDragging = false;
        pointerDraggedItem = null;
        currentOverZone = null;
        document.body.style.userSelect = ''; // Ensure user select is re-enabled
    }


    dropZones.forEach(zone => {
      // Native drag events for mouse drop handling
      zone.addEventListener('dragover', handleDragOverMouse);
      zone.addEventListener('dragleave', handleDragLeaveMouse);
      zone.addEventListener('drop', handleDropMouse);
    });

    function handleDragOverMouse(e) {
        e.preventDefault(); // Allow dropping
        // We rely on pointermove for consistent hover highlighting (.over class)
        e.dataTransfer.dropEffect = 'move';
    }

    function handleDragLeaveMouse(e) {
        // We rely on pointermove for consistent hover highlighting (.over class)
        // This native event can be finicky with children
    }

    function handleDropMouse(e) {
      // Handles the actual drop for a native mouse drag operation
      e.preventDefault();
      if (e.pointerType !== 'touch') {
        const id = e.dataTransfer.getData('text/plain');
        const droppedElement = document.getElementById(id);

        // Clean up class from original element (might be redundant if dragend fired)
        if (droppedElement) {
            droppedElement.classList.remove('native-dragging');
        }

        // Append element
        if (droppedElement && !e.currentTarget.contains(droppedElement)) {
          e.currentTarget.appendChild(droppedElement);
        }

        // Remove highlight from the target drop zone
        e.currentTarget.classList.remove('over');
        currentOverZone = null; // Reset hover state tracker
      }
    }

     // --- Pointer Event Handlers (Touch/Pen/Mouse) ---

    function handlePointerDown(e) {
        // Only primary button, no drag in progress
        if (e.button !== 0 || pointerDraggedItem) return;

        pointerDraggedItem = e.currentTarget; // Track the item being interacted with
        isTouchDragging = e.pointerType === 'touch'; // Set flag based on input type

        // IMPORTANT: Only preventDefault for touch to allow native mouse drag
        if (isTouchDragging) {
            // Prevent scroll/zoom etc. on touch AND prevent native drag start
            e.preventDefault();
            // Capture pointer is crucial for touch to keep receiving events
            pointerDraggedItem.setPointerCapture(e.pointerId);

            // Calculate offset for touch dragging positioning
            const rect = pointerDraggedItem.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;

            // Style the item for VISUAL touch dragging
            pointerDraggedItem.style.border = ''; // Clear validation border
            pointerDraggedItem.classList.add('dragging'); // Applies position: absolute
        } else {
            // For mouse, we DON'T preventDefault here, allowing native dragstart to fire.
            // We still capture the pointer to ensure pointermove/up events fire
            // reliably for hover detection and cleanup, even during a native drag.
             try { pointerDraggedItem.setPointerCapture(e.pointerId); } catch (err) {
                // Capturing might fail if native drag takes over immediately in some browsers
                console.warn("Could not capture pointer, native drag might interfere.", err);
             }
        }


        // Add common listeners to the document for move and end events
        document.addEventListener('pointermove', handlePointerMove);
        document.addEventListener('pointerup', handlePointerUp);
        document.addEventListener('pointercancel', handlePointerUp); // Treat cancel like up for cleanup

        // Prevent text selection during interaction
        document.body.style.userSelect = 'none';
    }

    function handlePointerMove(e) {
        // Only process if we are tracking an item AND the pointer ID matches
        if (!pointerDraggedItem || !pointerDraggedItem.hasPointerCapture(e.pointerId)) return;

        // --- Visual Position Update (TOUCH ONLY) ---
        if (isTouchDragging) {
            // Prevent scroll during touch move
            e.preventDefault();

            const gameRect = gameContainer.getBoundingClientRect();
            let newX = e.clientX - gameRect.left - offsetX;
            let newY = e.clientY - gameRect.top - offsetY;
            // Apply the styles directly for immediate feedback
            pointerDraggedItem.style.left = `${newX}px`;
            pointerDraggedItem.style.top = `${newY}px`;
        }
        // Else (Mouse): Native drag ghost handles visual movement

        // --- Drop Zone Highlighting (BOTH Touch and Mouse via Pointer Events) ---
        let elementUnderPointer = null;
        // Hide the element temporarily ONLY if it's touch-dragged (mouse uses ghost)
        const originalVisibility = isTouchDragging ? pointerDraggedItem.style.visibility : '';
        if (isTouchDragging) {
            pointerDraggedItem.style.visibility = 'hidden';
        }

        elementUnderPointer = document.elementFromPoint(e.clientX, e.clientY);

        if (isTouchDragging) {
            pointerDraggedItem.style.visibility = originalVisibility; // Restore visibility
        }

        let dropTarget = elementUnderPointer ? elementUnderPointer.closest('.drop-zone') : null;

        // Update .over class based on hover (works for both touch and mouse moves)
        if (currentOverZone && currentOverZone !== dropTarget) {
            currentOverZone.classList.remove('over'); // Remove from previous zone
        }
        if (dropTarget) {
            dropTarget.classList.add('over'); // Add to current zone
            currentOverZone = dropTarget;
        } else {
            currentOverZone = null; // No zone currently targeted
        }
    }

    // Combined handler for pointerup and pointercancel
    function handlePointerUp(e) {
        // Only process if we are tracking an item for this specific pointer
        if (!pointerDraggedItem || !pointerDraggedItem.hasPointerCapture(e.pointerId)) {
             // If pointer wasn't captured or doesn't match, clean up listeners just in case
             document.removeEventListener('pointermove', handlePointerMove);
             document.removeEventListener('pointerup', handlePointerUp);
             document.removeEventListener('pointercancel', handlePointerUp);
             document.body.style.userSelect = '';
             return;
        }

        // Remove global listeners immediately
        document.removeEventListener('pointermove', handlePointerMove);
        document.removeEventListener('pointerup', handlePointerUp);
        document.removeEventListener('pointercancel', handlePointerUp);
        document.body.style.userSelect = ''; // Re-enable text selection

        // --- Logic for TOUCH drop / interaction end ---
        if (isTouchDragging) {
            // Reset touch dragging styles FIRST
            pointerDraggedItem.classList.remove('dragging');
            pointerDraggedItem.style.left = '';
            pointerDraggedItem.style.top = '';
            pointerDraggedItem.style.visibility = ''; // Ensure visible

            // Perform drop logic for touch
            if (currentOverZone) {
                 // Check it's not already in the zone somehow
                if (!currentOverZone.contains(pointerDraggedItem)) {
                    currentOverZone.appendChild(pointerDraggedItem);
                }
                currentOverZone.classList.remove('over'); // Remove highlight
            } else {
                // Return to start if not dropped on a zone
                itemsContainer.appendChild(pointerDraggedItem);
            }
        }
        // --- Logic for MOUSE interaction end ---
        else {
            // For mouse, the actual placement is handled by the native 'drop' event.
            // Pointerup primarily cleans up pointer-specific state and hover effects.
            // Ensure original item is visible if native-dragging class was added
            pointerDraggedItem.classList.remove('native-dragging');

             // Clear any lingering zone highlights from pointermove detection
             // (native 'drop' or 'dragend' should also handle this, but belt-and-suspenders)
             if (currentOverZone) {
                 currentOverZone.classList.remove('over');
             }
        }

        // Common cleanup: Release pointer capture and reset state variables
        try { pointerDraggedItem.releasePointerCapture(e.pointerId); } catch(err) {
            // Might fail if capture was lost or never acquired (e.g., immediate native drag interference)
        }
        pointerDraggedItem = null;
        isTouchDragging = false;
        currentOverZone = null;
        offsetX = 0;
        offsetY = 0;
    }


    // --- Control Button Listeners (Unchanged) ---
    document.getElementById('check-btn').addEventListener('click', () => {
        let allCorrect = true; ['natural', 'processed'].forEach(zoneId => { const zone = document.getElementById(zoneId); Array.from(zone.children).forEach(item => { if (item.classList.contains('item')) { const isCorrect = item.dataset.category === zoneId; item.style.border = isCorrect ? '3px solid #22c55e' : '3px solid #ef4444'; if (!isCorrect) allCorrect = false; } }); }); Array.from(itemsContainer.children).forEach(item => { if (item.classList.contains('item')) { item.style.border = '3px solid #f97316'; allCorrect = false; } }); if(allCorrect && itemsContainer.children.length === 0) { console.log("All items placed correctly!"); /* alert("Congratulations! Everything is sorted correctly!"); */ }
    });
    document.getElementById('reset-btn').addEventListener('click', () => {
        initializeGame(); // Use initializeGame for clean reset
    });

    // --- Initial Game Setup ---
    initializeGame();

  });
  </script>
</body>
</html>
