<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sorting Game - Inherited Traits</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    /* ----------  CORE LAYOUT  ---------- */
    :root {
      /* Updated color palette - Muted Blue/Coral */
      --bg: #627a9c; /* User suggested muted blue */
      --panel: #F4E4C6; /* Kept light beige panel */
      --btn: #f7a072; /* Keep coral button */
      --btn-hover: #f4845f; /* Darker coral hover */
      /* Item styling variables */
      --label-bg: #fff;
      --label-border: #ccc;
      --target-border: #ccc;
      --correct-bg: #dff0d8;
      --correct-border: #22c55e;
      --text-dark: #333;
    }
    *{box-sizing:border-box;}
    body{
      margin:0; font-family:'Poppins',sans-serif; background:var(--bg);
      display:flex; flex-direction:column; align-items:center; padding:20px;
      overscroll-behavior: none;
    }
    /* White text on the new darker background */
    h1{font-size:2.5rem;color:#fff; margin:5px 0; text-shadow: 1px 1px 2px rgba(0,0,0,0.1);}
    p{color:#fff; margin:0 0 20px;}

    .game-container{
      background:var(--panel); width:100%; max-width:800px; padding:20px; border-radius:10px;
      position: relative;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }

    /* ----------  DRAG ITEMS (TEXT BOXES + EMOJI) ---------- */
    #items{
        display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin-bottom:20px;
        min-height: 80px;
        padding: 10px;
        background-color: #fff;
        border-radius: 8px;
        border: 2px dashed var(--label-border);
    }
    .item {
      padding: 8px 12px;
      background-color: var(--label-bg);
      border: 1px solid var(--label-border);
      border-radius: 6px;
      cursor: grab;
      font-weight: normal;
      color: var(--text-dark);
      touch-action: none;
      user-select: none;
      position: relative;
      transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, opacity 0.2s ease-out, background-color 0.2s, border-color 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      text-align: left;
      max-width: 220px;
    }
    .item-emoji {
        font-size: 1.2em;
        line-height: 1;
        pointer-events: none;
        user-select: none;
    }
     .item-text {
        pointer-events: none;
        user-select: none;
        line-height: 1.2;
        flex-shrink: 1;
     }
    .item.dragging { opacity: 0.7; cursor: grabbing; position: absolute; z-index: 1000; box-shadow: 0 5px 15px rgba(0,0,0,0.2); transform: scale(1.05); transition: none; background-color: var(--panel); }
    .item.native-dragging { opacity: 0.3; }

    /* ----------  DROP ZONES  ---------- */
    .zones{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:20px;}
    .zone-label{font-weight:bold;margin-bottom:5px;color:var(--text-dark);}
    .drop-zone{
        width:100%;min-height:150px;background:#fff;border:2px dashed var(--target-border);border-radius:8px;
        padding:10px;display:flex;flex-wrap:wrap;gap:10px;
        align-content: flex-start;
        transition:background .3s, border-style .3s;
    }
    .drop-zone.over{background:#fef9c3; border-style: solid;} /* Light yellow hover */
     /* Style for items dropped correctly in zones */
     .drop-zone .item {
         cursor: default;
         background-color: var(--correct-bg);
         border: 1px solid var(--correct-border);
         box-shadow: none;
         margin: 0;
         position: static !important;
         transform: none !important;
         opacity: 1 !important;
     }

    /* ----------  CONTROLS  ---------- */
    .controls{text-align:center;}
    .controls button{ background:var(--btn);color:#fff;border:none;padding:10px 20px;border-radius:10px;cursor:pointer; margin:10px 5px;font-size:1.2rem;font-family:'Poppins',sans-serif;transition:background .3s; }
    .controls button:hover{background:var(--btn-hover);}
  </style>
</head>
<body>
  <h1>Inherited Traits</h1>
  <p>Is the trait inherited from parents or not? Drag each description to the correct category.</p>

  <div class="game-container">
    <div id="items">
        </div>

    <div class="zones">
      <div class="zone">
        <div class="zone-label">Inherited Traits</div>
        <div id="inherited" class="drop-zone" aria-label="Inherited traits drop zone"></div>
      </div>
      <div class="zone">
        <div class="zone-label">Not Inherited</div>
        <div id="not-inherited" class="drop-zone" aria-label="Not inherited traits drop zone"></div>
      </div>
    </div>

    <div class="controls">
      <button id="check-btn" type="button">Check Answers</button>
      <button id="reset-btn" type="button">Reset</button>
    </div>
  </div>

  <script>
  /**
   * Sorting Game - Inherited vs Not Inherited Traits
   * v3 - Using text boxes + emoji, revised color scheme (muted blue)
   */
  document.addEventListener('DOMContentLoaded', () => {

    // --- ITEMS data for Inherited vs Not Inherited Traits ---
    const ITEMS = [
       {key:'eye_color', category:'inherited', label:'Eye Color: Blue', emoji:'ðŸ‘ï¸'},
       {key:'fur_color', category:'inherited', label:'Fur Color: Brown', emoji:'ðŸ»'},
       {key:'hair_type', category:'inherited', label:'Hair Type: Curly', emoji:'ðŸ§‘â€ðŸ¦±'},
       {key:'plant_height', category:'inherited', label:'Natural Plant Height: Tall', emoji:'ðŸŒ±'},
       {key:'tail_type', category:'inherited', label:'Tail Type: Stripes', emoji:'ðŸ…'},
       {key:'leaf_shape', category:'inherited', label:'Leaf Shape: Pointed', emoji:'ðŸ'},
       {key:'scar',      category:'not-inherited', label:'Has a Scar', emoji:'ðŸ©¹'},
       {key:'tricks',    category:'not-inherited', label:'Knows Tricks', emoji:'ðŸ¶'},
       {key:'language',  category:'not-inherited', label:'Speaks French', emoji:'ðŸ—£ï¸'},
       {key:'haircut',   category:'not-inherited', label:'Short Haircut', emoji:'âœ‚ï¸'},
       {key:'swimming',  category:'not-inherited', label:'Likes Swimming', emoji:'ðŸŠ'},
       {key:'dyed_hair', category:'not-inherited', label:'Dyed Hair: Pink', emoji:'ðŸ‘©â€ðŸŽ¤'}
     ];
    // --- End of ITEMS data ---

    const itemsPool = document.getElementById('items');
    const dropZones = document.querySelectorAll('.drop-zone');
    const gameContainer = document.querySelector('.game-container');

    // State variables
    let pointerDraggedItem = null;
    let offsetX = 0;
    let offsetY = 0;
    let currentOverZone = null;
    let isTouchDragging = false;

    // --- Initialization Function ---
    function initializeGame() {
        if (!itemsPool) { console.error("Element with ID 'items' not found!"); return; }
        itemsPool.innerHTML = '';
        dropZones.forEach(zone => { zone.innerHTML = ''; zone.classList.remove('over'); });
        const shuffledItems = [...ITEMS].sort(() => Math.random() - 0.5);

        shuffledItems.forEach((item, idx) => {
            const card = document.createElement('div');
            card.className = 'item';
            card.draggable = true;
            card.id = `item-${idx}`;
            card.dataset.category = item.category;

            const emojiChar = item.emoji;
            const labelText = item.label;
            card.innerHTML = `
                <span class="item-emoji" role="img" aria-label="${labelText}">${emojiChar}</span>
                <span class="item-text">${labelText}</span>
            `;

            card.addEventListener('dragstart', handleDragStartMouse);
            card.addEventListener('dragend', handleDragEndMouse);
            card.addEventListener('pointerdown', handlePointerDown);
            itemsPool.appendChild(card);
        });
        pointerDraggedItem = null;
        isTouchDragging = false;
        currentOverZone = null;
    }

    // --- Event Handlers (Mouse D&D, Pointer Events) ---
    // These functions remain IDENTICAL to the previous versions.
    // --- Standard Mouse D&D Handlers ---
    function handleDragStartMouse(e) { if (e.pointerType !== 'touch') { e.dataTransfer.setData('text/plain', e.currentTarget.id); e.dataTransfer.effectAllowed = 'move'; setTimeout(() => { e.target.classList.add('native-dragging'); }, 0); isTouchDragging = false; } else { e.preventDefault(); } }
    function handleDragEndMouse(e) { if (e.pointerType !== 'touch') { e.target.classList.remove('native-dragging'); dropZones.forEach(zone => zone.classList.remove('over')); } isTouchDragging = false; pointerDraggedItem = null; currentOverZone = null; document.body.style.userSelect = ''; }
    dropZones.forEach(zone => { zone.addEventListener('dragover', handleDragOverMouse); zone.addEventListener('dragleave', handleDragLeaveMouse); zone.addEventListener('drop', handleDropMouse); });
    function handleDragOverMouse(e) { e.preventDefault(); e.currentTarget.classList.add('over'); if (e.dataTransfer) e.dataTransfer.dropEffect = 'move'; }
    function handleDragLeaveMouse(e) { if (!e.currentTarget.contains(e.relatedTarget)) { e.currentTarget.classList.remove('over'); } }
    function handleDropMouse(e) { e.preventDefault(); if (e.pointerType !== 'touch') { const droppedItemId = e.dataTransfer.getData('text/plain'); const droppedElement = document.getElementById(droppedItemId); const targetZone = e.currentTarget; if (droppedElement && targetZone.classList.contains('drop-zone')) { targetZone.appendChild(droppedElement); } if(droppedElement) droppedElement.classList.remove('native-dragging'); targetZone.classList.remove('over'); currentOverZone = null; } }
    // --- Pointer Event Handlers ---
    function handlePointerDown(e) { if (e.button !== 0 || pointerDraggedItem) return; pointerDraggedItem = e.currentTarget; isTouchDragging = e.pointerType === 'touch'; if (isTouchDragging) { e.preventDefault(); pointerDraggedItem.setPointerCapture(e.pointerId); const rect = pointerDraggedItem.getBoundingClientRect(); offsetX = e.clientX - rect.left; offsetY = e.clientY - rect.top; pointerDraggedItem.classList.add('dragging'); handlePointerMove(e); } else { try { pointerDraggedItem.setPointerCapture(e.pointerId); } catch (err) {} } document.addEventListener('pointermove', handlePointerMove); document.addEventListener('pointerup', handlePointerUp); document.addEventListener('pointercancel', handlePointerUp); document.body.style.userSelect = 'none'; }
    function handlePointerMove(e) { if (!pointerDraggedItem || !pointerDraggedItem.hasPointerCapture(e.pointerId)) return; if (isTouchDragging) { e.preventDefault(); const gameRect = gameContainer.getBoundingClientRect(); let newX = e.clientX - gameRect.left - offsetX; let newY = e.clientY - gameRect.top - offsetY; pointerDraggedItem.style.left = `${newX}px`; pointerDraggedItem.style.top = `${newY}px`; } let elementUnderPointer = null; const originalVisibility = isTouchDragging ? pointerDraggedItem.style.visibility : ''; if (isTouchDragging) { pointerDraggedItem.style.visibility = 'hidden'; } elementUnderPointer = document.elementFromPoint(e.clientX, e.clientY); if (isTouchDragging) { pointerDraggedItem.style.visibility = originalVisibility; } let dropTarget = elementUnderPointer ? elementUnderPointer.closest('.drop-zone') : null; if (currentOverZone && currentOverZone !== dropTarget) { currentOverZone.classList.remove('over'); } if (dropTarget) { dropTarget.classList.add('over'); currentOverZone = dropTarget; } else { currentOverZone = null; } }
    function handlePointerUp(e) { if (!pointerDraggedItem || !pointerDraggedItem.hasPointerCapture(e.pointerId)) { document.removeEventListener('pointermove', handlePointerMove); document.removeEventListener('pointerup', handlePointerUp); document.removeEventListener('pointercancel', handlePointerUp); document.body.style.userSelect = ''; return; } document.removeEventListener('pointermove', handlePointerMove); document.removeEventListener('pointerup', handlePointerUp); document.removeEventListener('pointercancel', handlePointerUp); document.body.style.userSelect = ''; if (isTouchDragging) { pointerDraggedItem.classList.remove('dragging'); pointerDraggedItem.style.left = ''; pointerDraggedItem.style.top = ''; pointerDraggedItem.style.visibility = ''; if (currentOverZone) { currentOverZone.appendChild(pointerDraggedItem); currentOverZone.classList.remove('over'); } else { itemsPool.appendChild(pointerDraggedItem); } } else { pointerDraggedItem.classList.remove('native-dragging'); if (currentOverZone) { currentOverZone.classList.remove('over'); } } try { pointerDraggedItem.releasePointerCapture(e.pointerId); } catch(err) {} pointerDraggedItem = null; isTouchDragging = false; currentOverZone = null; offsetX = 0; offsetY = 0; }


    // --- Control Button Listeners ---
    document.getElementById('check-btn').addEventListener('click', () => {
        let allCorrect = true;
        const zoneIds = ['inherited', 'not-inherited'];
        zoneIds.forEach(zoneId => {
            const zone = document.getElementById(zoneId);
            if (!zone) { console.error(`Drop zone with ID ${zoneId} not found!`); return; }
            Array.from(zone.children).forEach(item => {
                if (item.classList.contains('item')) {
                    const isCorrect = item.dataset.category === zoneId;
                    item.style.border = isCorrect ? `3px solid var(--correct-border)` : '3px solid #ef4444';
                    if (!isCorrect) allCorrect = false;
                }
            });
        });
       Array.from(itemsPool.children).forEach(item => {
           if (item.classList.contains('item')) {
               item.style.border = '3px solid #f97316';
               allCorrect = false;
           }
       });
       if(allCorrect && itemsPool.children.length === 0) {
         console.log("All items placed correctly!");
       }
    });
    document.getElementById('reset-btn').addEventListener('click', () => {
         document.querySelectorAll('.item').forEach(item => item.style.border = ''); // Reset borders
        initializeGame();
    });

    // --- Initial Game Setup ---
    initializeGame();

  });
  </script>
</body>
</html>
