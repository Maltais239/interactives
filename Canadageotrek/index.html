<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CanadaTrek</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            font-family: 'Poppins', sans-serif;
            background-color: #f1f5f9;
            overflow: hidden;
        }
        #map {
            flex: 1;
            height: 100%;
            border-right: 1px solid #ddd;
            background-color: #aadaff;
        }
        #info-panel {
            width: 380px;
            max-width: 40%;
            padding: 2rem;
            background: linear-gradient(135deg, #ffffff 0%, #f1f5f9 100%);
            border-left: 5px solid #4f46e5;
            overflow-y: auto;
            box-shadow: -5px 0 15px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }
        #info-panel h2 {
            margin-top: 0;
            color: #312e81;
            font-size: 1.75rem;
            font-weight: 700;
            border-bottom: 2px solid #c7d2fe;
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
            text-align: center;
        }
        .loading-text {
            text-align: center; font-weight: 500; color: #4338ca; padding: 2rem;
        }
        .stats-container {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        #score-display, #distance-display {
            flex: 1;
            text-align: center; font-size: 1.1rem; font-weight: 600; color: #4338ca;
            background-color: #eef2ff;
            padding: 0.75rem; border-radius: 8px;
            border: 1px solid #c7d2fe;
        }
        #score-display span, #distance-display span { font-weight: 700; color: #4f46e5; }

        .switcher {
            display: flex; margin-bottom: 1rem; border-radius: 8px; padding: 0.25rem; flex-wrap: wrap;
        }
        .switcher-btn {
            flex: 1 1 auto; padding: 0.75rem 0.5rem; border: none; background-color: transparent;
            font-size: 0.9rem; font-weight: 600; cursor: pointer; border-radius: 6px;
            transition: background-color 0.3s, color 0.3s;
        }
        .mode-switcher { background-color: #e0e7ff; }
        .mode-btn { color: #3730a3; }
        .mode-btn.active { background-color: #4338ca; color: white; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        
        .mode-toggle { margin-bottom: 1.5rem; }
        #touchscreen-mode-btn { width: 100%; background-color: #64748b; }
        #touchscreen-mode-btn.active { background-color: #1e293b; }

        #trek-panel { border-top: 1px solid #ddd; padding-top: 1.5rem; }
        #trek-challenge {
            padding: 1rem; background-color: #eef2ff; border: 1px solid #c7d2fe;
            border-radius: 8px; margin-bottom: 1.5rem; text-align: center; font-size: 1.1rem;
            font-weight: 500; color: #4338ca; line-height: 1.6;
        }
        #trek-challenge strong { color: #4f46e5; }
        #trek-input-container { display: flex; gap: 0.5rem; margin-bottom: 1.5rem; }
        #trek-guess-input {
            flex: 1; padding: 0.75rem; border: 1px solid #c7d2fe; border-radius: 8px;
            font-size: 1rem; font-family: 'Poppins', sans-serif;
        }
        .game-btn {
            padding: 0.75rem; color: white; border: none; border-radius: 8px; font-size: 1rem;
            font-weight: 600; cursor: pointer; transition: background-color 0.2s, opacity 0.2s;
        }
        .game-btn:disabled { opacity: 0.6; cursor: not-allowed; }
        #trek-guess-btn { padding: 0.75rem 1rem; background-color: #4f46e5; }
        #trek-guess-btn:hover { background-color: #4338ca; }
        #trek-hint-btn { background-color: #f59e0b; }
        #trek-hint-btn:hover { background-color: #d97706; }
        
        #trek-guesses-list { list-style: none; padding: 0; margin-bottom: 1rem; }
        #trek-guesses-list li { padding: 0.5rem; border-radius: 4px; margin-bottom: 0.25rem; }
        #trek-guesses-list li.correct { background-color: #dcfce7; color: #166534; }
        #trek-guesses-list li.incorrect { background-color: #fee2e2; color: #991b1b; }

        #trek-choices-container { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 1.5rem; }
        .choice-btn { padding: 1rem 0.5rem; background-color: #4f46e5; }
        .choice-btn:hover { background-color: #4338ca; }

        #trek-feedback { font-weight: 500; text-align: center; padding: 1rem; min-height: 50px; }
        #new-trek-btn {
            background-color: #16a34a; width: 100%; margin-top: auto; padding-top: 1rem;
        }
        #new-trek-btn:hover { background-color: #15803d; }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="info-panel">
        <h2>üçÅ CanadaTrek üçÅ</h2>
        <div class="stats-container">
            <div id="score-display">Score: <span id="score-value">0</span></div>
            <div id="distance-display" style="display: none;">Km: <span id="distance-value">0</span></div>
        </div>
        <div class="switcher mode-switcher">
            <button class="switcher-btn mode-btn active" data-mode="province">Province Trek</button>
            <button class="switcher-btn mode-btn" data-mode="capital">Capital Trek</button>
        </div>
        <div class="mode-toggle">
            <button id="touchscreen-mode-btn" class="game-btn">Enable Touchscreen Mode ‚å®Ô∏è</button>
        </div>
        <div id="trek-panel">
            <div id="trek-challenge">Loading new trek...</div>
            <div id="trek-input-container">
                <input type="text" id="trek-guess-input" placeholder="Enter province/territory...">
                <button id="trek-hint-btn" class="game-btn">Hint üí°</button>
                <button id="trek-guess-btn" class="game-btn">Guess</button>
            </div>
            <div id="trek-choices-container" style="display: none;"></div>
            <div id="trek-guesses">
                <ul id="trek-guesses-list"></ul>
            </div>
            <div id="trek-feedback"></div>
            <button id="new-trek-btn" class="game-btn">New Trek üó∫Ô∏è</button>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script>
        // --- DOM Elements ---
        const map = L.map('map').setView([62, -98], 3.5);
        L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd', maxZoom: 10, minZoom: 3,
        }).addTo(map);

        const modeBtns = document.querySelectorAll('.mode-btn');
        const scoreValue = document.getElementById('score-value');
        const distanceDisplay = document.getElementById('distance-display');
        const distanceValue = document.getElementById('distance-value');
        const touchscreenModeBtn = document.getElementById('touchscreen-mode-btn');
        const trekChallenge = document.getElementById('trek-challenge');
        const trekInputContainer = document.getElementById('trek-input-container');
        const trekGuessInput = document.getElementById('trek-guess-input');
        const trekGuessBtn = document.getElementById('trek-guess-btn');
        const trekHintBtn = document.getElementById('trek-hint-btn');
        const trekChoicesContainer = document.getElementById('trek-choices-container');
        const trekGuessesList = document.getElementById('trek-guesses-list');
        const trekFeedback = document.getElementById('trek-feedback');
        const newTrekBtn = document.getElementById('new-trek-btn');

        // --- App State ---
        let geojson;
        let trekState = {};
        let currentMode = 'province';
        let currentScore = 0;
        let isTouchscreenMode = false;
        let capitalMarkers = {};
        let trekPathLayer = null;

        // --- Data ---
        const provinceData = {
            'British Columbia': { capital: 'Victoria', borders: ['Alberta', 'Yukon Territory', 'Northwest Territories'], coords: [48.4284, -123.3656] },
            'Alberta': { capital: 'Edmonton', borders: ['British Columbia', 'Saskatchewan', 'Northwest Territories'], coords: [53.5461, -113.4938] },
            'Saskatchewan': { capital: 'Regina', borders: ['Alberta', 'Manitoba', 'Northwest Territories'], coords: [50.4452, -104.6189] },
            'Manitoba': { capital: 'Winnipeg', borders: ['Saskatchewan', 'Ontario', 'Nunavut'], coords: [49.8951, -97.1384] },
            'Ontario': { capital: 'Toronto', borders: ['Manitoba', 'Quebec'], coords: [43.6532, -79.3832] },
            'Quebec': { capital: 'Quebec City', borders: ['Ontario', 'New Brunswick', 'Newfoundland and Labrador'], coords: [46.8139, -71.2080] },
            'New Brunswick': { capital: 'Fredericton', borders: ['Quebec', 'Nova Scotia', 'Prince Edward Island'], coords: [45.9636, -66.6431] },
            'Nova Scotia': { capital: 'Halifax', borders: ['New Brunswick'], coords: [44.6488, -63.5752] },
            'Prince Edward Island': { capital: 'Charlottetown', borders: ['New Brunswick'], coords: [46.2382, -63.1311] }, // Connected by Confederation Bridge
            'Newfoundland and Labrador': { capital: 'St. John\'s', borders: ['Quebec'], coords: [47.5615, -52.7126] },
            'Yukon Territory': { capital: 'Whitehorse', borders: ['British Columbia', 'Northwest Territories'], coords: [60.7212, -135.0568] },
            'Northwest Territories': { capital: 'Yellowknife', borders: ['Yukon Territory', 'British Columbia', 'Alberta', 'Saskatchewan', 'Nunavut'], coords: [62.4540, -114.3718] },
            'Nunavut': { capital: 'Iqaluit', borders: ['Northwest Territories', 'Manitoba'], coords: [63.7467, -68.5170] }
        };
        const capitalToProvinceMap = Object.fromEntries(Object.entries(provinceData).map(([prov, data]) => [data.capital.toLowerCase(), prov]));

        // --- Main Logic ---
        function initializeGame(geoData) {
            geoData.features.forEach(feature => {
                if (feature.properties.name === "Yukon") {
                    feature.properties.name = "Yukon Territory";
                }
            });
            geojson = L.geoJson(geoData, { style, onEachFeature }).addTo(map);
            setupCapitalMarkers();
            startNewTrek();
        }

        function setupCapitalMarkers() {
            for (const provName in provinceData) {
                const data = provinceData[provName];
                const marker = L.circleMarker(data.coords, {
                    radius: 8, fillColor: "#64748b", color: "#fff",
                    weight: 2, opacity: 1, fillOpacity: 0.8
                }).addTo(map);
                marker.bindTooltip(data.capital);
                marker.on('click', () => handleGuess(data.capital));
                capitalMarkers[provName] = marker;
            }
        }

        function findPath(startName, endName) {
            let queue = [[startName]];
            const visited = new Set([startName]);
            while (queue.length > 0) {
                let path = queue.shift();
                let currentName = path[path.length - 1];
                if (currentName === endName) return path;
                const neighbors = provinceData[currentName]?.borders || [];
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push(path.concat(neighbor));
                    }
                }
            }
            return null;
        }

        function startNewTrek() {
            if (trekPathLayer) { map.removeLayer(trekPathLayer); trekPathLayer = null; }
            Object.values(capitalMarkers).forEach(m => m.setStyle({ fillColor: "#64748b", radius: 8 }));
            
            const candidateProvinces = Object.keys(provinceData);
            let start, end, path;
            let attempts = 0;
            do {
                start = candidateProvinces[Math.floor(Math.random() * candidateProvinces.length)];
                end = candidateProvinces[Math.floor(Math.random() * candidateProvinces.length)];
                path = findPath(start, end);
                attempts++;
            } while (attempts < 200 && (start === end || !path || path.length < 3));

            if (!path || path.length < 3) { startNewTrek(); return; }

            trekState = {
                start, end, current: start, pathTaken: [start],
                optimalPathLength: path.length - 1, isComplete: false, hintUsed: false, totalDistance: 0
            };

            trekPathLayer = L.layerGroup().addTo(map);

            if (currentMode === 'province') {
                trekChallenge.innerHTML = `Your trek starts in <strong>${start}</strong> and your destination is <strong>${end}</strong>.`;
                distanceDisplay.style.display = 'none';
                trekGuessInput.placeholder = "Enter province/territory...";
                Object.values(capitalMarkers).forEach(m => m.setRadius(0));
            } else {
                trekChallenge.innerHTML = `Trek from <strong>${provinceData[start].capital}</strong> (${start}) to <strong>${provinceData[end].capital}</strong> (${end}).`;
                distanceDisplay.style.display = 'block';
                distanceValue.textContent = '0';
                trekGuessInput.placeholder = "Enter capital city...";
                Object.values(capitalMarkers).forEach(m => m.setRadius(8));
                capitalMarkers[start].setStyle({ fillColor: '#16a34a', radius: 10 }); // Start - Green, Larger
                capitalMarkers[end].setStyle({ fillColor: '#f97316' });   // End - Orange
            }

            trekGuessesList.innerHTML = '';
            trekFeedback.innerHTML = `You are currently in ${trekState.current}.`;
            trekGuessInput.value = '';
            
            updateUIMode();
            if (!isTouchscreenMode) {
                trekGuessInput.disabled = false;
                trekGuessBtn.disabled = false;
                trekHintBtn.disabled = false;
                trekGuessInput.focus();
            }

            if (geojson) {
                 geojson.resetStyle();
                 const startLayer = getLayerByName(start);
                 const endLayer = getLayerByName(end);
                 if (startLayer && endLayer) {
                     const bounds = L.latLngBounds(startLayer.getBounds(), endLayer.getBounds());
                     map.flyToBounds(bounds.pad(0.3));
                 }
            }
        }

        async function handleGuess(guessValue) {
            if (trekState.isComplete) return;

            let officialName, isValidMove = false, distance = 0;
            const guess = guessValue.trim().toLowerCase();
            const neighbors = provinceData[trekState.current].borders;
            const li = document.createElement('li');

            if (currentMode === 'province') {
                officialName = Object.keys(provinceData).find(p => p.toLowerCase() === guess);
                if (officialName && neighbors.includes(officialName)) isValidMove = true;
            } else {
                const guessedProvince = capitalToProvinceMap[guess];
                if (guessedProvince && neighbors.includes(guessedProvince)) {
                    isValidMove = true;
                    officialName = guessedProvince;
                    const [lat1, lon1] = provinceData[trekState.current].coords;
                    const [lat2, lon2] = provinceData[officialName].coords;
                    distance = getDistance(lat1, lon1, lat2, lon2);
                }
            }
            li.textContent = guessValue.trim();

            if (isValidMove) {
                const prevProvince = trekState.current;
                trekState.pathTaken.push(officialName);
                trekState.current = officialName;
                li.className = 'correct';
                let feedback = `Correct! You are now in ${officialName}.`;

                if (currentMode === 'capital') {
                    const prevCoords = provinceData[prevProvince].coords;
                    const currentCoords = provinceData[officialName].coords;
                    await drawRoute(prevCoords, currentCoords);
                    
                    capitalMarkers[prevProvince].setStyle({ fillColor: '#7e22ce', radius: 8 }); // Visited - Purple
                    capitalMarkers[officialName].setStyle({ fillColor: '#2563eb', radius: 10 }); // Current - Blue, Larger
                }

                if (distance > 0) {
                    trekState.totalDistance += distance;
                    feedback = `Correct! You traveled ${distance.toFixed(0)} km to ${provinceData[officialName].capital}.`;
                    distanceValue.textContent = trekState.totalDistance.toFixed(0);
                }
                trekFeedback.innerHTML = feedback;
                
                if (officialName === trekState.end) {
                    trekState.isComplete = true;
                    capitalMarkers[officialName].setStyle({ fillColor: '#f97316', radius: 8 }); // Final is orange
                    const stepsTaken = trekState.pathTaken.length - 1;
                    const points = calculateScore(stepsTaken);
                    currentScore += points;
                    scoreValue.textContent = currentScore;
                    let endMessage = `Congratulations! You reached ${trekState.end} in ${stepsTaken} steps and earned ${points} points!`;
                    if (trekState.totalDistance > 0) {
                        endMessage += ` You traveled a total of ${trekState.totalDistance.toFixed(0)} km!`
                    }
                    trekFeedback.innerHTML = `${endMessage} Loading next trek...`;
                    setTimeout(startNewTrek, 5000);
                } else if (isTouchscreenMode) {
                    generateTouchscreenChoices();
                }

            } else {
                li.className = 'incorrect';
                trekFeedback.innerHTML = `That's not a valid move from ${trekState.current}. Try again!`;
            }
            
            trekGuessesList.appendChild(li);
            trekGuessInput.value = '';
            if (!isTouchscreenMode) trekGuessInput.focus();
            if (geojson && currentMode === 'province') geojson.resetStyle();
        }
        
        // --- UI & Event Handlers ---
        newTrekBtn.addEventListener('click', startNewTrek);
        trekGuessBtn.addEventListener('click', () => handleGuess(trekGuessInput.value));
        trekGuessInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') handleGuess(trekGuessInput.value); });
        trekHintBtn.addEventListener('click', provideHint);
        touchscreenModeBtn.addEventListener('click', toggleTouchscreenMode);

        modeBtns.forEach(btn => btn.addEventListener('click', () => {
            currentMode = btn.dataset.mode;
            modeBtns.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            startNewTrek();
        }));
       
        function provideHint() {
            if (trekState.isComplete || trekState.hintUsed) return;
            const hintPath = findPath(trekState.current, trekState.end);
            if (hintPath && hintPath.length > 1) {
                trekState.hintUsed = true;
                trekHintBtn.disabled = true; 
                const hintProvince = hintPath[1];
                const hintText = currentMode === 'capital' ? provinceData[hintProvince].capital : hintProvince;
                trekFeedback.innerHTML = `A hint costs points! Try heading to <strong>${hintText}</strong>.`;
            }
        }
        
        function calculateScore(stepsTaken) {
            const basePoints = 250;
            const efficiencyBonus = Math.max(0, (trekState.optimalPathLength * 50) - ((stepsTaken - trekState.optimalPathLength) * 25));
            let total = basePoints + efficiencyBonus;
            if (trekState.hintUsed) total *= 0.5;
            return Math.round(total);
        }

        function toggleTouchscreenMode() {
            isTouchscreenMode = !isTouchscreenMode;
            updateUIMode();
        }

        function updateUIMode() {
             if (isTouchscreenMode) {
                touchscreenModeBtn.textContent = 'Disable Touchscreen Mode üíª';
                touchscreenModeBtn.classList.add('active');
                trekInputContainer.style.display = 'none';
                trekChoicesContainer.style.display = 'grid';
                if (!trekState.isComplete) generateTouchscreenChoices();
            } else {
                touchscreenModeBtn.textContent = 'Enable Touchscreen Mode ‚å®Ô∏è';
                touchscreenModeBtn.classList.remove('active');
                trekInputContainer.style.display = 'flex';
                trekChoicesContainer.style.display = 'none';
                trekChoicesContainer.innerHTML = '';
                if (!trekState.isComplete) trekGuessInput.focus();
            }
        }

        function generateTouchscreenChoices() {
            if (trekState.isComplete) return;
            const neighbors = provinceData[trekState.current].borders;
            if (neighbors.length === 0) {
                trekChoicesContainer.innerHTML = '<p>No land borders from here!</p>'; return;
            }

            const optimalPath = findPath(trekState.current, trekState.end);
            let optimalChoice = (optimalPath && optimalPath.length > 1) ? optimalPath[1] : neighbors[0];
            
            const choices = new Set([optimalChoice]);
            const otherNeighbors = neighbors.filter(n => n !== optimalChoice).sort(() => 0.5 - Math.random());
            otherNeighbors.forEach(n => choices.size < 4 && choices.add(n));

            const allProvinces = Object.keys(provinceData);
            const distractors = allProvinces.filter(p => p !== trekState.current && !neighbors.includes(p));
            while (choices.size < 4 && distractors.length > 0) {
                const randIndex = Math.floor(Math.random() * distractors.length);
                choices.add(distractors.splice(randIndex, 1)[0]);
            }

            const shuffledChoices = Array.from(choices).sort(() => 0.5 - Math.random());
            trekChoicesContainer.innerHTML = '';
            shuffledChoices.forEach(provName => {
                const choiceText = currentMode === 'capital' ? provinceData[provName].capital : provName;
                const btn = document.createElement('button');
                btn.className = 'game-btn choice-btn';
                btn.textContent = choiceText;
                btn.addEventListener('click', () => handleGuess(choiceText));
                trekChoicesContainer.appendChild(btn);
            });
        }
        
        // --- Utility ---
        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of the Earth in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        async function drawRoute(fromCoords, toCoords) {
            const [lat1, lon1] = fromCoords;
            const [lat2, lon2] = toCoords;
            const url = `https://router.project-osrm.org/route/v1/driving/${lon1},${lat1};${lon2},${lat2}?overview=full&geometries=geojson`;

            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data.routes && data.routes.length > 0) {
                    const routeGeometry = data.routes[0].geometry;
                    L.geoJSON(routeGeometry, {
                        style: { color: '#2563eb', weight: 4, opacity: 0.7 }
                    }).addTo(trekPathLayer);
                } else {
                    L.polyline([fromCoords, toCoords], { color: '#2563eb', weight: 3, dashArray: '5, 5' }).addTo(trekPathLayer);
                }
            } catch (error) {
                console.error("Routing error:", error);
                L.polyline([fromCoords, toCoords], { color: '#2563eb', weight: 3, dashArray: '5, 5' }).addTo(trekPathLayer);
            }
        }

        // --- Map Styling & Interaction ---
        function getLayerByName(name) {
            let foundLayer = null;
            if (geojson) {
                geojson.eachLayer(layer => {
                    if (layer.feature.properties.name === name) {
                        foundLayer = layer;
                    }
                });
            }
            return foundLayer;
        }

        function style(feature) {
            const name = feature.properties.name;
            if (currentMode === 'capital') {
                 if (trekState.start && (name === trekState.start || name === trekState.end)) {
                    return { fillColor: '#e0e7ff', weight: 1, color: '#f5f5f5', fillOpacity: 0.6 };
                 }
            } else if (trekState.start) { // Province mode styling
                if (name === trekState.start) return { fillColor: '#16a34a', weight: 2, color: 'white', fillOpacity: 0.9 };
                if (name === trekState.end) return { fillColor: '#f97316', weight: 2, color: 'white', fillOpacity: 0.9 };
                if (trekState.pathTaken.includes(name)) return { fillColor: '#2563eb', weight: 1.5, color: 'white', fillOpacity: 0.8 };
            }
            return { fillColor: '#e0e0e0', weight: 1, color: '#f5f5f5', fillOpacity: 0.5 };
        }

        function onEachFeature(feature, layer) {
            layer.on('click', () => {
                if (currentMode === 'province') {
                    handleGuess(feature.properties.name);
                }
            });
        }

        // --- Initial Load ---
        fetch('https://cdn.jsdelivr.net/gh/codeforgermany/click_that_hood@master/public/data/canada.geojson')
            .then(res => res.json())
            .then(data => initializeGame(data))
            .catch(err => { console.error('GeoJSON load error:', err); });
    </script>
</body>
</html>

