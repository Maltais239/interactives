<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Definition Draw</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f1f5f9;
        }
        #drawing-canvas {
            background: #fff;
            border: 1px solid #cbd5e1;
            border-radius: 10px;
            touch-action: none;
            cursor: crosshair;
        }
        .color-btn.active {
            outline: 3px solid black;
            transform: scale(1.1);
        }
        #drawing-canvas.fill-cursor {
            cursor: copy;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 flex flex-col items-center justify-center min-h-screen p-4">

    <!-- Start Screen -->
    <div id="start-screen" class="w-full max-w-2xl text-center">
        <div class="bg-white p-8 rounded-2xl shadow-lg">
            <h1 id="start-title" class="text-4xl font-bold text-teal-600 mb-4">Definition Draw</h1>
            <p class="text-slate-600 mb-8">A simple game to help you visualize vocabulary. Draw the term based on its definition.</p>
            <div id="error-message" class="text-red-500 font-semibold my-4 hidden"></div>
            <div class="flex flex-col sm:flex-row gap-4 justify-center">
                <button id="start-sample-btn" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-transform transform hover:scale-105">
                    Start Sample Game
                </button>
                <button id="import-json-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-transform transform hover:scale-105">
                    Import Custom Set (.json)
                </button>
                <input type="file" id="json-importer" class="hidden" accept=".json">
            </div>
        </div>
    </div>

    <!-- Game Screen -->
    <main id="game-screen" class="w-full max-w-3xl bg-white rounded-2xl shadow-lg p-4 flex-col gap-4 hidden">
        <!-- Header -->
        <div class="flex items-center justify-between flex-wrap gap-2">
            <div class="flex items-center gap-3">
                 <button id="main-menu-btn" class="text-sm bg-slate-200 hover:bg-slate-300 text-slate-700 px-3 py-1 rounded">Main Menu</button>
                <h1 id="term" class="text-2xl font-bold text-teal-600">Term</h1>
                <button id="hint-btn" class="text-sm bg-slate-200 hover:bg-slate-300 text-slate-700 px-3 py-1 rounded">Hint</button>
            </div>
            <div id="color-palette" class="flex items-center gap-2">
                <button class="color-btn w-6 h-6 rounded-full bg-black active" data-color="black"></button>
                <button class="color-btn w-6 h-6 rounded-full bg-red-500" data-color="#ef4444"></button>
                <button class="color-btn w-6 h-6 rounded-full bg-green-500" data-color="#22c55e"></button>
                <button class="color-btn w-6 h-6 rounded-full bg-blue-500" data-color="#3b82f6"></button>
                <button class="color-btn w-6 h-6 rounded-full bg-yellow-400" data-color="#facc15"></button>
                <button class="color-btn w-6 h-6 rounded-full bg-purple-500" data-color="#8b5cf6"></button>
                <button class="color-btn w-6 h-6 rounded-full bg-orange-500" data-color="#f97316"></button>
                <button class="color-btn w-6 h-6 rounded-full bg-amber-700" data-color="#b45309"></button>
            </div>
        </div>
         <!-- Drawing Tools -->
        <div class="flex items-center justify-center gap-4 my-2">
            <label for="brush-size" class="text-sm">Brush Size:</label>
            <input type="range" id="brush-size" min="1" max="50" value="3" class="w-32">
            <button id="fill-btn" class="flex items-center gap-1 bg-violet-500 hover:bg-violet-600 text-white text-sm px-3 py-1 rounded" title="Fill">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M2.522 8.357A.5.5 0 0 0 3 8.5v5a.5.5 0 0 0 .5.5h9a.5.5 0 0 0 .5-.5v-5a.5.5 0 0 0-.478-.495l-9.5-2a.5.5 0 0 0-.022.002zm-.54-1.111a1.5 1.5 0 0 1 1.523-.69L8 8.443l4.05-1.928a1.5 1.5 0 0 1 1.523.69l.3 1.285a.5.5 0 1 1-.948.222l-.3-1.285a.5.5 0 0 0-.508-.23L8.35 7.64a.5.5 0 0 1-.399.034L3.89 5.86a.5.5 0 0 0-.508.23l-.3 1.285a.5.5 0 1 1-.948-.222l.3-1.285z"/>
                    <path d="M12.5 3a2.5 2.5 0 0 0-5 0h-1a3.5 3.5 0 0 1 7 0h-1z"/>
                </svg>
            </button>
            <button id="undo-btn" class="bg-slate-200 hover:bg-slate-300 text-slate-700 text-sm px-3 py-1 rounded">Undo</button>
            <button id="clear-canvas-btn" class="bg-slate-200 hover:bg-slate-300 text-slate-700 text-sm px-3 py-1 rounded">Clear</button>
        </div>


        <!-- Definition -->
        <p id="definition" class="text-slate-600 hidden my-2 bg-slate-50 p-3 rounded-md"></p>

        <!-- Drawing Area -->
        <canvas id="drawing-canvas" width="700" height="400" class="w-full"></canvas>

        <!-- Footer -->
        <button id="done-btn" class="w-full mt-4 bg-green-500 hover:bg-green-600 text-white font-semibold py-2 rounded">I'm Done!</button>
    </main>
    
    <!-- Result Modal -->
    <div id="result-modal" class="fixed inset-0 bg-black bg-opacity-60 hidden items-center justify-center p-4">
        <div class="bg-white rounded-2xl shadow-2xl p-8 w-full max-w-4xl text-center">
            <h2 class="text-3xl font-bold mb-6">How did you do?</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <div>
                    <h3 class="text-xl font-semibold mb-2">Your Drawing</h3>
                    <img id="user-drawing" src="" alt="Your drawing" class="w-full h-auto rounded-lg bg-slate-50 border">
                </div>
                <div>
                    <h3 class="text-xl font-semibold mb-2">Sample Image</h3>
                    <img id="correct-image" src="" alt="Correct image" class="w-full h-auto rounded-lg bg-slate-50 border">
                </div>
            </div>
            <button id="next-word-btn" class="mt-6 bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-lg shadow-md transition-transform transform hover:scale-105">Next Word</button>
        </div>
    </div>


    <script>
        // --- DOM Elements ---
        const startScreen = document.getElementById('start-screen');
        const gameScreen = document.getElementById('game-screen');
        const startSampleBtn = document.getElementById('start-sample-btn');
        const importJsonBtn = document.getElementById('import-json-btn');
        const jsonImporter = document.getElementById('json-importer');
        const errorMessage = document.getElementById('error-message');
        
        // Game screen elements
        const termEl = document.getElementById('term');
        const defEl = document.getElementById('definition');
        const hintBtn = document.getElementById('hint-btn');
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const clearBtn = document.getElementById('clear-canvas-btn');
        const doneBtn = document.getElementById('done-btn');
        const colorPalette = document.getElementById('color-palette');
        const mainMenuBtn = document.getElementById('main-menu-btn');
        const brushSizeSlider = document.getElementById('brush-size');
        const fillBtn = document.getElementById('fill-btn');
        const undoBtn = document.getElementById('undo-btn');
        
        // Modal elements
        const resultModal = document.getElementById('result-modal');
        const userDrawingImg = document.getElementById('user-drawing');
        const correctImage = document.getElementById('correct-image');
        const nextWordBtn = document.getElementById('next-word-btn');


        // --- Game State ---
        let vocabulary = [];
        let currentWordIndex = 0;
        let isDrawing = false;
        let penColor = 'black';
        let penWidth = 3;
        let isFillMode = false;
        let historyStack = [];
        let historyIndex = -1;

        // --- Default Data ---
        const DEFAULT_VOCABULARY = [
            { term: 'Volcano', definition: 'A mountain or hill, typically conical, having a crater or vent through which lava and gas are or have been erupted.', imageSrc: 'https://placehold.co/400x400/f87171/7f1d1d?text=Volcano' },
            { term: 'Peninsula', definition: 'A piece of land almost surrounded by water or projecting out into a body of water.', imageSrc: 'https://placehold.co/400x400/60a5fa/1e3a8a?text=Peninsula' },
            { term: 'Canyon', definition: 'A deep gorge with steep sides, often carved by a river.', imageSrc: 'https://placehold.co/400x400/fcd34d/b45309?text=Canyon' }
        ];

        // --- Initialization ---
        function init() {
            // Start screen listeners
            startSampleBtn.addEventListener('click', () => {
                hideErrorMessage();
                startGame(DEFAULT_VOCABULARY);
            });
            importJsonBtn.addEventListener('click', () => {
                hideErrorMessage();
                jsonImporter.click();
            });
            jsonImporter.addEventListener('change', handleFileUpload);
        }
        
        // --- UI Helpers ---
        function showErrorMessage(message) {
            errorMessage.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        function hideErrorMessage() {
            if (!errorMessage.classList.contains('hidden')) {
                errorMessage.classList.add('hidden');
            }
        }

        // --- File Handling ---
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const customVocab = JSON.parse(e.target.result);
                    const standardizedVocab = customVocab.map(item => ({
                        ...item,
                        imageSrc: item.imageSrc || item.image 
                    }));

                    if (Array.isArray(standardizedVocab) && standardizedVocab.length > 0 && standardizedVocab.every(item => item.term && item.definition && item.imageSrc)) {
                        startGame(standardizedVocab);
                    } else {
                        showErrorMessage('Invalid JSON. Must have "term", "definition", and "imageSrc" (or "image").');
                    }
                } catch (error) {
                    console.error("JSON Parse Error:", error);
                    showErrorMessage('Error reading the JSON file. It might be malformed.');
                }
            };
            reader.readAsText(file);
            event.target.value = null;
        }

        // --- Game Flow ---
        function startGame(vocabSet) {
            vocabulary = vocabSet;
            currentWordIndex = 0;
            
            startScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            gameScreen.classList.add('flex');
            
            setupGameListeners();
            loadWord();
        }

        function returnToMenu() {
            gameScreen.classList.add('hidden');
            gameScreen.classList.remove('flex');
            startScreen.classList.remove('hidden');
            isFillMode = false;
            canvas.classList.remove('fill-cursor');
        }
        
        function setupGameListeners() {
            canvas.addEventListener('mousedown', handleCanvasClick);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('touchstart', handleCanvasClick, { passive: false });
            canvas.addEventListener('touchmove', draw, { passive: false });
            canvas.addEventListener('touchend', stopDrawing);
            
            hintBtn.onclick = () => defEl.classList.toggle('hidden');
            clearBtn.onclick = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                saveState();
            };
            
            doneBtn.onclick = showResult;
            nextWordBtn.onclick = nextWord;

            mainMenuBtn.onclick = returnToMenu;

            colorPalette.addEventListener('click', (e) => {
                if (e.target.classList.contains('color-btn')) {
                    penColor = e.target.dataset.color;
                    colorPalette.querySelector('.active').classList.remove('active');
                    e.target.classList.add('active');
                }
            });

            brushSizeSlider.oninput = (e) => {
                penWidth = e.target.value;
            };

            fillBtn.onclick = () => {
                isFillMode = true;
                canvas.classList.add('fill-cursor');
            };
            
            undoBtn.onclick = undo;
        }

        function loadWord() {
            termEl.textContent = vocabulary[currentWordIndex].term;
            defEl.textContent = vocabulary[currentWordIndex].definition;
            defEl.classList.add('hidden');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            historyStack = [];
            historyIndex = -1;
            saveState();
        }
        
        function showResult() {
            const drawingUrl = canvas.toDataURL('image/png');
            userDrawingImg.src = drawingUrl;
            correctImage.src = vocabulary[currentWordIndex].imageSrc;
            resultModal.classList.remove('hidden');
            resultModal.classList.add('flex');
        }

        function nextWord() {
            resultModal.classList.add('hidden');
            resultModal.classList.remove('flex');
            currentWordIndex = (currentWordIndex + 1) % vocabulary.length;
            loadWord();
        }

        // --- Canvas Drawing Functions ---
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.round((e.touches ? e.touches[0].clientX : e.clientX) - rect.left);
            const y = Math.round((e.touches ? e.touches[0].clientY : e.clientY) - rect.top);
            return { x, y };
        }

        function handleCanvasClick(e) {
            if (isFillMode) {
                const { x, y } = getPos(e);
                floodFill(x, y, hexToRgb(penColor));
                isFillMode = false;
                canvas.classList.remove('fill-cursor');
                saveState();
            } else {
                startDrawing(e);
            }
        }

        function startDrawing(e) {
            isDrawing = true;
            const { x, y } = getPos(e);
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const { x, y } = getPos(e);
            ctx.lineTo(x, y);
            ctx.strokeStyle = penColor;
            ctx.lineWidth = penWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
        }

        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            ctx.closePath();
            saveState();
        }

        // --- Undo Logic ---
        function saveState() {
            historyIndex++;
            if (historyIndex < historyStack.length) {
                historyStack.length = historyIndex;
            }
            historyStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                ctx.putImageData(historyStack[historyIndex], 0, 0);
            }
        }

        // --- Fill Logic ---
        function hexToRgb(hex) {
            if (hex === 'black') return { r: 0, g: 0, b: 0, a: 255 };
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16),
                a: 255
            } : null;
        }

        function floodFill(startX, startY, fillColor) {
            if (!fillColor) return;
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const startPos = (startY * canvas.width + startX) * 4;
            const startR = data[startPos];
            const startG = data[startPos + 1];
            const startB = data[startPos + 2];
            const startA = data[startPos + 3];

            if (fillColor.r === startR && fillColor.g === startG && fillColor.b === startB && fillColor.a === startA) {
                return; // Clicked on same color
            }

            const pixelStack = [[startX, startY]];
            while (pixelStack.length) {
                let [x, y] = pixelStack.pop();
                let currentPos = (y * canvas.width + x) * 4;

                // Go up as long as we're in the right color
                while (y >= 0 && (data[currentPos] === startR && data[currentPos + 1] === startG && data[currentPos + 2] === startB && data[currentPos + 3] === startA)) {
                    y--;
                    currentPos -= canvas.width * 4;
                }
                currentPos += canvas.width * 4;
                y++;
                
                let reachLeft = false;
                let reachRight = false;
                
                while (y < canvas.height -1 && (data[currentPos] === startR && data[currentPos + 1] === startG && data[currentPos + 2] === startB && data[currentPos + 3] === startA)) {
                    data[currentPos] = fillColor.r;
                    data[currentPos + 1] = fillColor.g;
                    data[currentPos + 2] = fillColor.b;
                    data[currentPos + 3] = fillColor.a;

                    if (x > 0) {
                        if (data[currentPos - 4] === startR && data[currentPos - 3] === startG && data[currentPos - 2] === startB && data[currentPos - 1] === startA) {
                            if (!reachLeft) {
                                pixelStack.push([x - 1, y]);
                                reachLeft = true;
                            }
                        } else if (reachLeft) {
                            reachLeft = false;
                        }
                    }

                    if (x < canvas.width - 1) {
                         if (data[currentPos + 4] === startR && data[currentPos + 5] === startG && data[currentPos + 6] === startB && data[currentPos + 7] === startA) {
                            if (!reachRight) {
                                pixelStack.push([x + 1, y]);
                                reachRight = true;
                            }
                        } else if (reachRight) {
                            reachRight = false;
                        }
                    }
                    y++;
                    currentPos += canvas.width * 4;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }
        
        // --- Start the app ---
        init();
    </script>

</body>
</html>

