<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Draggable Canada Puzzle</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: 'Poppins', sans-serif;
            background-color: #f0f4f8;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #header {
            padding: 1rem;
            text-align: center;
            color: #374151;
            background-color: #ffffff;
            width: 100%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            border-bottom: 3px solid #d91e2a;
        }

        #header h1 {
            margin: 0;
            font-size: 1.75rem;
        }
        #header p {
            margin: 0.25rem 0 0 0;
            color: #6b7280;
        }

        #canvas-container {
            flex-grow: 1;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            background: linear-gradient(135deg, #aadaff 0%, #dce7ff 100%);
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>Canadian Province Puzzle</h1>
        <p>Click and drag the pieces to assemble the map of Canada!</p>
    </div>
    <div id="canvas-container" touch-action="none"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Basic Setup ---
        const container = document.getElementById('canvas-container');
        let scene, camera, renderer, raycaster, mouse;
        let provinceMeshes = [];
        let selectedObject = null;
        let offset = new THREE.Vector3();
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

        // --- Palette for provinces ---
        const palette = ['#e57373', '#ffb74d', '#fff176', '#aed581', '#64b5f6', '#ba68c8', '#ff8a65', '#f06292', '#dce775', '#4dd0e1', '#bcaaa4', '#a5d6a7', '#ce93d8'];

        function init() {
            // --- Scene and Camera ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f4f8);

            const aspect = container.clientWidth / container.clientHeight;
            const frustumSize = 150;
            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2,
                frustumSize * aspect / 2,
                frustumSize / 2,
                frustumSize / -2,
                1,
                1000
            );
            camera.position.z = 5;

            // --- Renderer ---
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            const canvasElement = renderer.domElement;
            container.appendChild(canvasElement);
            
            // --- Raycaster and Mouse ---
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // --- Event Listeners ---
            canvasElement.addEventListener('pointerdown', onPointerDown);
            canvasElement.addEventListener('pointermove', onPointerMove);
            canvasElement.addEventListener('pointerup', onPointerUp);
            window.addEventListener('resize', onWindowResize);
            
            // --- Initial Load ---
            loadGeoData();
        }

        function loadGeoData() {
            fetch('https://cdn.jsdelivr.net/gh/codeforgermany/click_that_hood@master/public/data/canada.geojson')
                .then(res => res.json())
                .then(data => {
                    processGeoJSON(data);
                    animate();
                })
                .catch(err => {
                    console.error('GeoJSON load error:', err);
                    container.innerHTML = '<p>Error loading map data. Please refresh.</p>';
                });
        }

        function processGeoJSON(data) {
            // Find the bounding box of the entire country to scale it properly
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            data.features.forEach(feature => {
                const coords = feature.geometry.coordinates;
                const type = feature.geometry.type;
                const polygons = (type === 'Polygon') ? [coords] : coords;
                
                polygons.forEach(polygon => {
                    polygon[0].forEach(point => {
                        minX = Math.min(minX, point[0]);
                        maxX = Math.max(maxX, point[0]);
                        minY = Math.min(minY, point[1]);
                        maxY = Math.max(maxY, point[1]);
                    });
                });
            });

            const scale = 140; // Arbitrary scale factor for the puzzle size
            const offsetX = (minX + maxX) / 2;
            const offsetY = (minY + maxY) / 2;

            data.features.forEach((feature, index) => {
                const color = new THREE.Color(palette[index % palette.length]);
                const geometry = feature.geometry;
                const polygons = (geometry.type === 'Polygon') ? [geometry.coordinates] : geometry.coordinates;

                polygons.forEach(polygonCoords => {
                    const shape = new THREE.Shape();
                    // Outer boundary
                    polygonCoords[0].forEach((p, i) => {
                        const x = (p[0] - offsetX) * (scale / (maxX - minX));
                        const y = (p[1] - offsetY) * (scale / (maxY - minY)) * 1.5; // Adjust for aspect ratio
                        if (i === 0) shape.moveTo(x, y);
                        else shape.lineTo(x, y);
                    });

                    // Holes
                    for (let i = 1; i < polygonCoords.length; i++) {
                        const holePath = new THREE.Path();
                        polygonCoords[i].forEach((p, j) => {
                           const x = (p[0] - offsetX) * (scale / (maxX - minX));
                           const y = (p[1] - offsetY) * (scale / (maxY - minY)) * 1.5;
                           if (j === 0) holePath.moveTo(x, y);
                           else holePath.lineTo(x, y);
                        });
                        shape.holes.push(holePath);
                    }
                    
                    const shapeGeom = new THREE.ShapeGeometry(shape);
                    const material = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
                    const mesh = new THREE.Mesh(shapeGeom, material);
                    
                    // Assign random starting positions
                    mesh.position.x = (Math.random() - 0.5) * 120;
                    mesh.position.y = (Math.random() - 0.5) * 80;
                    
                    // Store province name for potential future use (e.g., tooltips)
                    mesh.userData.name = feature.properties.name;
                    
                    scene.add(mesh);
                    provinceMeshes.push(mesh);
                });
            });
        }
        
        // --- Interaction ---
        function updateMousePosition(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }
        
        function onPointerDown(event) {
            updateMousePosition(event);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(provinceMeshes, true);

            if (intersects.length > 0) {
                // Bring selected piece to the front
                selectedObject = intersects[0].object;
                const group = selectedObject.parent;
                group.remove(selectedObject);
                group.add(selectedObject);
                
                // Calculate offset from object center to click point
                const intersectionPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectionPoint);
                offset.copy(intersectionPoint).sub(selectedObject.position);
            }
        }

        function onPointerMove(event) {
            if (selectedObject) {
                updateMousePosition(event);
                raycaster.setFromCamera(mouse, camera);

                const intersectionPoint = new THREE.Vector3();
                if (raycaster.ray.intersectPlane(plane, intersectionPoint)) {
                    selectedObject.position.copy(intersectionPoint).sub(offset);
                }
            }
        }

        function onPointerUp() {
            selectedObject = null;
        }

        // --- Window Resizing ---
        function onWindowResize() {
            const aspect = container.clientWidth / container.clientHeight;
            camera.left = -75 * aspect;
            camera.right = 75 * aspect;
            camera.top = 75;
            camera.bottom = -75;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // --- Start ---
        init();
    </script>
</body>
</html>

