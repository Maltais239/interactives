<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Canada SVG Puzzle â€“ OFFLINE</title>
  <style>
    :root {
      --bg: #f8f9fa;
      --ink: #212529;
      --border-color: #dee2e6;
      --primary: #007bff;
      --success: #28a745;
    }
    html, body {
      height: 100%;
      margin: 0;
    }
    body {
      background: var(--bg);
      color: var(--ink);
      font: 16px/1.6 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow: hidden;
    }
    #stage {
      position: fixed;
      inset: 0;
      background: #f1f3f5;
    }
    #boardWrap {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      padding: 50px 20px 20px;
      box-sizing: border-box;
    }
    svg#board {
      width: 100%;
      height: 100%;
      max-width: 1400px;
      aspect-ratio: 1000/600;
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 8px 30px rgba(0,0,0,.1);
      touch-action: none;
    }
    #targets path {
      fill: #e9ecef;
      stroke: #ced4da;
      stroke-width: 1;
    }
    #targets g.done path {
      fill: #d4edda;
      stroke: #b2dfc0;
    }
    #pieces g.piece {
      cursor: grab;
      transition: filter 0.2s ease, opacity 0.2s ease;
      filter: drop-shadow(0 4px 8px rgba(0,0,0,.15));
    }
    #pieces g.piece:hover {
       filter: drop-shadow(0 6px 12px rgba(0,0,0,.2));
    }
    #pieces g.piece.dragging {
      cursor: grabbing;
      opacity: .85;
      filter: drop-shadow(0 8px 16px rgba(0,0,0,.25));
    }
    #pieces g.piece.placed {
      cursor: default;
      filter: none;
      opacity: 1;
    }
    .controls {
      position: absolute;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 10;
      background: rgba(255,255,255,.7);
      padding: 8px;
      border-radius: 12px;
      backdrop-filter: blur(5px);
    }
    .btn {
      background: #fff;
      color: #343a40;
      border: 1px solid #ced4da;
      border-radius: 8px;
      padding: 8px 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,.05);
    }
    .btn:hover {
      background: #f8f9fa;
      border-color: #adb5bd;
      transform: translateY(-1px);
    }

    /* Win Modal Styles */
    #winModal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    #winModal.show {
      opacity: 1;
      visibility: visible;
    }
    .win-modal-content {
      background: white;
      padding: 40px;
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }
    #winModal.show .win-modal-content {
      transform: scale(1);
    }
    .win-modal-content h2 {
      margin-top: 0;
      font-size: 2.5rem;
      color: var(--success);
    }
    .win-modal-content p {
      margin-bottom: 24px;
      font-size: 1.1rem;
      color: #495057;
    }
  </style>
</head>
<body>
  <div id="stage">
    <div id="boardWrap">
      <svg id="board" viewBox="0 0 1000 600" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <clipPath id="boardClip"><rect x="0" y="0" width="1000" height="600" /></clipPath>
        </defs>
        <g clip-path="url(#boardClip)">
          <g id="targets"></g>
          <g id="pieces"></g>
        </g>
      </svg>
    </div>
  </div>
  <div class="controls"><button class="btn" id="shuffle">Shuffle</button><button class="btn" id="reset">Reset</button></div>
  
  <div id="winModal">
    <div class="win-modal-content">
      <h2>Congratulations!</h2>
      <p>You've successfully assembled Canada.</p>
      <button class="btn" id="playAgain">Play Again</button>
    </div>
  </div>

  <script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>
  <script>
    const log = (...a) => console.log('[puzzle]', ...a);
    const gTargets = document.getElementById('targets');
    const gPieces = document.getElementById('pieces');
    const BOARD_WIDTH = 1000, BOARD_HEIGHT = 600;
    let projection, path, features = [], targetsByName = {};

    // Curated color palette inspired by your image, slightly darker
    const provinceColors = {
      'British Columbia': '#e09489',
      'Alberta': '#e2ac91',
      'Saskatchewan': '#eecb8a',
      'Manitoba': '#9ed47a',
      'Ontario': '#8cb7e0',
      'Quebec': '#a8c2e4',
      'New Brunswick': '#79d0e0',
      'Nova Scotia': '#6fd283',
      'Prince Edward Island': '#e08371',
      'Newfoundland and Labrador': '#b1a0cf',
      'Yukon Territory': '#b1c6b1',
      'Northwest Territories': '#e0b8a8',
      'Nunavut': '#bac0e0',
      'Unknown': '#92b3b5'
    };
    function getColorForProvince(name) {
      return provinceColors[name] || provinceColors['Unknown'];
    }

    function normName(p) { return p.name || p.province || p.NAME || p.admin || p.abbrev || 'Unknown' }
    
    function fitProjection(fc) { 
      projection = d3.geoMercator().fitSize([BOARD_WIDTH, BOARD_HEIGHT], fc);
      path = d3.geoPath(projection);
    }

    function geoToPaths(fc) {
      fitProjection(fc);
      gTargets.innerHTML = '';
      targetsByName = {};
      const tg = d3.select(gTargets).selectAll('g').data(fc.features).enter().append('g').attr('data-name', d => normName(d.properties));
      tg.append('path').attr('d', d => path(d)).attr('fill-rule', 'evenodd').attr('vector-effect', 'non-scaling-stroke');
      tg.each(function (d) { const n = normName(d.properties); const c = path.centroid(d); targetsByName[n] = { x: c[0], y: c[1], path: path(d), node: this } });
      spawnPieces(fc);
    }

    function spawnPieces(fc) {
      d3.select(gPieces).selectAll('*').remove();
      const sh = d3.shuffle([...fc.features]);
      const cols = 5, padX = 40, padY = BOARD_HEIGHT - 220, cell = 120;
      let i = 0;
      const pcs = d3.select(gPieces).selectAll('g.piece').data(sh, d => normName(d.properties)).enter().append('g').attr('class', 'piece').attr('data-name', d => normName(d.properties)).call(d3.drag().on('start', dragStarted).on('drag', dragged).on('end', dragEnded));
      pcs.each(function (d) {
        const g = d3.select(this);
        const c = path.centroid(d);
        g.attr('data-cx', c[0]).attr('data-cy', c[1]);
        g.append('path')
          .attr('d', path(d))
          .attr('fill', getColorForProvince(normName(d.properties)))
          .attr('stroke', '#ffffff')
          .attr('stroke-width', 2)
          .attr('fill-rule', 'evenodd')
          .attr('vector-effect', 'non-scaling-stroke');
      });
      pcs.attr('transform', function () {
        const cx = +this.getAttribute('data-cx');
        const cy = +this.getAttribute('data-cy');
        const x = padX + (i % cols) * cell + (Math.random() * 40 - 20);
        const y = padY + Math.floor(i / cols) * 90 + (Math.random() * 30 - 15);
        i++;
        return `translate(${x - cx}, ${y - cy})`
      });
    }

    function getTranslate(el) { const m = /translate\(([-0-9.]+),\s*([-0-9.]+)\)/.exec(el.getAttribute('transform') || 'translate(0,0)'); return { x: +m[1], y: +m[2] } }
    function dragStarted(e) { if (this.classList.contains('placed')) return; d3.select(this).raise(); this.classList.add('dragging'); this._t0 = getTranslate(this) }
    function dragged(e) { if (this.classList.contains('placed')) return; const x = this._t0.x + e.dx; const y = this._t0.y + e.dy; this.setAttribute('transform', `translate(${x},${y})`); this._t0 = { x, y } }
    function dragEnded(e) {
      this.classList.remove('dragging');
      if (this.classList.contains('placed')) return;
      const name = this.getAttribute('data-name');
      const tgt = targetsByName[name];
      if (!tgt) return;
      const t = getTranslate(this);
      const cx = +this.getAttribute('data-cx');
      const cy = +this.getAttribute('data-cy');
      const cur = { x: t.x + cx, y: t.y + cy };
      const dist = Math.hypot(cur.x - tgt.x, cur.y - tgt.y);
      const R = 35; // Increased snap radius
      if (dist < R) {
        const nx = t.x + (tgt.x - cur.x);
        const ny = t.y + (tgt.y - cur.y);
        d3.select(this).transition().duration(250).attr('transform', `translate(${nx},${ny})`).on('end', () => {
          this.classList.add('placed');
          d3.select(tgt.node).classed('done', true);
          checkWin();
        });
      }
    }

    function checkWin() {
      const all = [...gPieces.querySelectorAll('g.piece')];
      if (all.length && all.every(n => n.classList.contains('placed'))) {
        document.getElementById('winModal').classList.add('show');
      }
    }

    document.getElementById('shuffle').onclick = () => spawnPieces({ type: 'FeatureCollection', features });
    document.getElementById('reset').onclick = () => {
        document.getElementById('winModal').classList.remove('show');
        geoToPaths({ type: 'FeatureCollection', features });
    };
    document.getElementById('playAgain').onclick = () => {
        document.getElementById('winModal').classList.remove('show');
        geoToPaths({ type: 'FeatureCollection', features });
    };

    function coerceToFeatureCollection(d) { if (d.type === 'FeatureCollection') return d; if (d.type === 'Feature') return { type: 'FeatureCollection', features: [d] }; if (Array.isArray(d)) return { type: 'FeatureCollection', features: d }; throw new Error('Unsupported GeoJSON structure') }
    function pickCanadaFeatures(fc) { const keep = fc.features.filter(f => f.geometry && /Polygon/i.test(f.geometry.type)); const expected = new Set(['British Columbia', 'Alberta', 'Saskatchewan', 'Manitoba', 'Ontario', 'Quebec', 'New Brunswick', 'Nova Scotia', 'Prince Edward Island', 'Newfoundland and Labrador', 'Yukon Territory', 'Northwest Territories', 'Nunavut']); const withNames = keep.filter(f => expected.has((f.properties || {}).name) || expected.has((f.properties || {}).province) || expected.has((f.properties || {}).NAME)); const chosen = withNames.length === 13 ? withNames : keep; return { type: 'FeatureCollection', features: chosen } }
    function initWithGeoJSON(raw) { const fc = pickCanadaFeatures(coerceToFeatureCollection(raw)); features = fc.features; geoToPaths(fc) }

    (function start() { fetch('https://cdn.jsdelivr.net/gh/codeforgermany/click_that_hood@master/public/data/canada.geojson').then(r => r.json()).then(d => initWithGeoJSON(d)); })();
  </script>
</body>
</html>

