<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Canada SVG Puzzle â€“ drag provinces into place</title>
  <style>
    :root { --bg:#0b1020; --panel:#0e1532; --ink:#e8ecf6; --accent:#7dd3fc; --ok:#16a34a; --warn:#f59e0b; --border:#223; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body { display:grid; grid-template-columns: 1fr 360px; gap:0; background: var(--bg); color: var(--ink); font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #stage { position: relative; background:#09112a; }
    #boardWrap { position:absolute; inset:0; display:grid; place-items:center; }
    svg#board { width: 100%; height: 100%; max-width: 1200px; aspect-ratio: 1000/600; background:#eef5fb; border-right:1px solid #c7d4e9; touch-action:none; }
    /* Targets (faint map in correct spots) */
    #targets path { fill:#e7eef8; stroke:#bcd3f5; stroke-width:1; }
    #targets g.done path { fill:#eaf7ee; stroke:#a7e3ba; }

    /* Draggable pieces */
    #pieces g.piece { cursor: grab; filter: drop-shadow(0 2px 6px rgba(0,0,0,.3)); }
    #pieces g.piece.dragging { cursor: grabbing; opacity:.9; }
    #pieces g.piece.placed { cursor: default; filter:none; }

    aside { border-left:1px solid var(--border); background: var(--panel); padding:14px; overflow:auto; }
    h1 { font-size: 18px; margin:0 0 8px 0; }
    .muted { opacity:.85; }
    .row { display:flex; gap:8px; align-items:center; margin:10px 0; }
    .btn { background:#172149; color:#cde; border:1px solid #30427a; border-radius:10px; padding:8px 12px; font-weight:600; cursor:pointer; }
    .btn:hover { filter:brightness(1.08); }
    input[type="file"] { width:100%; }
    .log { font-family: ui-monospace, Menlo, Consolas, monospace; background:#0a1128; border:1px solid #22345e; border-radius:8px; padding:10px; height:140px; overflow:auto; white-space:pre-wrap; }
    .ok { color:#22c55e; }
  </style>
</head>
<body>
  <div id="stage">
    <div id="boardWrap">
      <svg id="board" viewBox="0 0 1000 600" xmlns="http://www.w3.org/2000/svg">
        <g id="targets"></g>
        <g id="pieces"></g>
      </svg>
    </div>
  </div>
  <aside>
    <h1>Canada SVG Puzzle</h1>
    <p class="muted">Drag each province/territory shape to its spot. When itâ€™s close, it <em>snaps</em> and locks. Works with your GeoJSON, or use the default.</p>
    <div class="row">
      <button class="btn" id="shuffle">Shuffle</button>
      <button class="btn" id="reset">Reset</button>
    </div>
    <div class="row">
      <input type="file" id="file" accept=".json,.geojson" />
    </div>
    <div class="log" id="log"></div>
  </aside>

  <script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>
  <script>
    const logEl = document.getElementById('log');
    const log = (...a)=>{ logEl.textContent += a.join(' ') + '\n'; logEl.scrollTop = logEl.scrollHeight; };

    const board = document.getElementById('board');
    const gTargets = document.getElementById('targets');
    const gPieces  = document.getElementById('pieces');
    const fileInput = document.getElementById('file');

    const W = 1000, H = 600; // board viewBox

    let projection, path, features=[], targetsByName={}, piecesByName={};

    function normName(props){
      // Handle differing property keys across datasets
      return props.name || props.province || props.NAME || props.admin || props.abbrev || 'Unknown';
    }

    function colorFor(name){
      // stable bright-ish color
      let h=0; for(const c of name) h=(h*31 + c.charCodeAt(0))>>>0; return `hsl(${h%360} 80% 60%)`;
    }

    function fitProjection(fc){
      projection = d3.geoMercator().fitSize([W,H], fc);
      path = d3.geoPath(projection);
    }

    function geoToPaths(fc){
      fitProjection(fc);
      // Draw targets (true positions)
      gTargets.innerHTML='';
      targetsByName={};
      const targetG = d3.select(gTargets)
        .selectAll('g').data(fc.features).enter().append('g').attr('data-name',d=>normName(d.properties));
      targetG.append('path').attr('d', d=>path(d)).attr('fill', '#e7eef8').attr('stroke','#bcd3f5').attr('stroke-width',1);
      targetG.each(function(d){
        const name = normName(d.properties);
        const c = path.centroid(d);
        targetsByName[name] = { x:c[0], y:c[1], path: path(d), node:this };
      });

      // Spawn shuffled pieces
      spawnPieces(fc);
    }

    function spawnPieces(fc){
      d3.select(gPieces).selectAll('*').remove();
      piecesByName={};
      const shuffled = d3.shuffle([...fc.features]);
      const cols = 5, padX=40, padY=H-180, cell=110;
      let i=0;
      const pieces = d3.select(gPieces).selectAll('g.piece')
        .data(shuffled, d=>normName(d.properties))
        .enter().append('g')
          .attr('class','piece')
          .attr('data-name', d=>normName(d.properties))
          .each(function(d){ piecesByName[normName(d.properties)] = this; })
          .call(d3.drag()
            .on('start', dragStarted)
            .on('drag', dragged)
            .on('end', dragEnded)
          );

      // draw paths and center each piece around its own centroid so it can be moved anywhere
      pieces.each(function(d){
        const g = d3.select(this);
        const c = path.centroid(d); // in board coordinates
        g.attr('data-cx', c[0]).attr('data-cy', c[1]);
        g.append('path')
          .attr('d', path(d))
          .attr('fill', colorFor(normName(d.properties)))
          .attr('stroke', '#1f2937')
          .attr('stroke-width', 1);
      });

      // Initial random-ish positions at bottom of board â€” translate by (x - cx, y - cy)
      pieces.attr('transform', function(){
        const cx = +this.getAttribute('data-cx');
        const cy = +this.getAttribute('data-cy');
        const x = padX + (i%cols)*cell + (Math.random()*40-20);
        const y = padY + Math.floor(i/cols)*80 + (Math.random()*30-15);
        i++;
        return `translate(${x - cx},${y - cy})`;
      });
    }

    function getTranslate(el){
      const m = /translate\(([-0-9.]+),\s*([-0-9.]+)\)/.exec(el.getAttribute('transform')||'translate(0,0)');
      return {x: +m[1], y:+m[2]};
    }

    function dragStarted(event){
      if(this.classList.contains('placed')) return;
      this.classList.add('dragging');
      this._t0 = getTranslate(this);
    }
    function dragged(event){
      if(this.classList.contains('placed')) return;
      const x = this._t0.x + event.dx; const y = this._t0.y + event.dy;
      this.setAttribute('transform', `translate(${x},${y})`);
      this._t0 = {x,y};
    }
    function dragEnded(event){
      this.classList.remove('dragging');
      if(this.classList.contains('placed')) return;
      const name = this.getAttribute('data-name');
      const tgt = targetsByName[name]; if(!tgt) return;
      // With pieces centered on their own centroid, the current centroid = translate + (cx, cy)
      const t = getTranslate(this);
      const cx = +this.getAttribute('data-cx');
      const cy = +this.getAttribute('data-cy');
      const current = { x: t.x + cx, y: t.y + cy };
      const dist = Math.hypot(current.x - tgt.x, current.y - tgt.y);
      const snapRadius = 28; // pixels in board space
      if(dist < snapRadius){
        // Snap so centroid aligns exactly
        const nx = t.x + (tgt.x - current.x);
        const ny = t.y + (tgt.y - current.y);
        this.setAttribute('transform', `translate(${nx},${ny})`);
        this.classList.add('placed');
        this.style.filter = 'none';
        d3.select(tgt.node).classed('done', true);
        log('âœ”', name, 'placed');
        checkWin();
      }
    }

    function checkWin(){
      const all = [...gPieces.querySelectorAll('g.piece')];
      if(all.length && all.every(n=>n.classList.contains('placed'))){
        log('ðŸŽ‰ All pieces placed!');
        alert('Great job! All provinces and territories placed.');
      }
    }

    // Buttons
    document.getElementById('shuffle').onclick = ()=> spawnPieces({type:'FeatureCollection', features});
    document.getElementById('reset').onclick = ()=> geoToPaths({type:'FeatureCollection', features});

    // File loader (your SimpleMaps GeoJSON)
    fileInput.addEventListener('change', async (e)=>{
      const f = e.target.files[0]; if(!f) return;
      const text = await f.text();
      try{
        const data = JSON.parse(text);
        initWithGeoJSON(data);
        log('Loaded GeoJSON from file:', f.name);
      }catch(err){
        log('Error parsing file:', err.message);
      }
    });

    function coerceToFeatureCollection(data){
      if(data.type === 'FeatureCollection') return data;
      if(data.type === 'Feature') return { type:'FeatureCollection', features:[data] };
      if(Array.isArray(data)) return { type:'FeatureCollection', features:data };
      throw new Error('Unsupported GeoJSON structure');
    }

    function pickCanadaFeatures(fc){
      // Keep only province/territory polygon features
      const keep = fc.features.filter(f=> (f.geometry && /Polygon/i.test(f.geometry.type)) );
      // If dataset contains the full world, filter by admin=Canada when present
      const filtered = keep.filter(f=>{
        const p=f.properties||{}; const admin=p.admin||p.country||p.COUNTRY||p.sov_a3||'';
        return (String(admin).toLowerCase().includes('canada')) || keep.length<=20; // heuristic
      });
      return { type:'FeatureCollection', features: filtered };
    }

    function initWithGeoJSON(raw){
      const fc = pickCanadaFeatures(coerceToFeatureCollection(raw));
      features = fc.features;
      geoToPaths(fc);
    }

    // Fallback: load a public Canada provinces GeoJSON (in case no file is provided)
    fetch('https://cdn.jsdelivr.net/gh/codeforgermany/click_that_hood@master/public/data/canada.geojson')
      .then(res=>res.json())
      .then(data=>{ initWithGeoJSON(data); log('Loaded default Canada GeoJSON.'); })
      .catch(err=>{ log('Failed to load default map:', err.message); });
  </script>
</body>
</html>
