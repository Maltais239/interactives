<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocabulary Invaders</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');
       
        body {
            background-color: #0d1117; /* Dark space background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            font-family: 'Space Mono', monospace;
            color: #ffffff;
        }

        .game-container {
            border: 4px solid #00f0ff; /* Neon blue border */
            box-shadow: 0 0 20px #00f0ff, 0 0 5px rgba(0, 240, 255, 0.5);
            background: #000000;
            border-radius: 8px;
            padding: 10px;
            width: 90%;
            max-width: 600px;
        }

        canvas {
            display: block;
            background-color: #1a1f25;
            border: 2px solid #00f0ff;
            border-radius: 4px;
        }

        #game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 5px;
            font-size: 0.9rem;
            color: #ffffff;
        }

        #definition-box {
            background: #333;
            color: #ffcc00; /* Gold text for definition */
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 1rem;
            box-shadow: inset 0 0 5px #ffcc00;
        }

        .difficulty-controls button {
            background: linear-gradient(145deg, #00ffaa, #00cc88); /* Green gradient */
            box-shadow: 0 4px #009966;
            margin: 0 5px;
            width: 30%;
            padding: 10px;
        }
        .difficulty-controls button:hover {
            background: linear-gradient(145deg, #00cc88, #00ffaa);
            box-shadow: 0 2px #009966;
            transform: translateY(2px);
        }
       
        .start-button-group {
            display: flex;
            justify-content: center;
            margin-top: 15px;
            Choose a difficulty level to start: Easy, Medium, or Challenge!
        </div>

        <div id="game-info" class="mb-2">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
        </div>

        <canvas id="gameCanvas" width="600" height="400"></canvas>
       
        <div class="start-button-group difficulty-controls">
            <button id="easyButton">Easy</button>
            <button id="mediumButton">Medium</button>
            <button id="challengeButton">Challenge</button>
        </div>

        <!-- Mobile/Touch Controls -->
        <div class="controls md:hidden">
            <button class="control-button" id="leftButton"> &lt; Move Left </button>
            <button class="control-button" id="rightButton"> Move Right &gt; </button>
        </div>
        <!-- Note: Tap the canvas on mobile to shoot, or use the Space Bar on desktop. -->
    </div>

    <!-- Game Over/Message Overlay -->
    <div id="message-overlay">
        <div id="message-box">
            <div id="message-text">Game Over!</div>
            <button id="retryButton">Play Again</button>
        </div>
    </div>

    <script>
        // --- GAME DATA AND CONFIGURATION ---
        const VOCABULARY = [
            { term: "Historical Site", definition: "A special place that is important to our past." },
            { term: "Landforms", definition: "The natural shapes of the land, like mountains, hills, or flat prairies." },
            { term: "Landmark", definition: "An important place or building that is easy to recognize." },
            { term: "Natural Resources", definition: "Things from nature that people use, like water, trees, and oil." },
            { term: "Physical Features", definition: "The different parts of the land you can see, like rivers, lakes, and mountains." },
            { term: "Political Boundaries", definition: "The lines on a map that show where a province or country begins and ends." },
            { term: "Territory", definition: "An area of land that belongs to a group of people." },
            { term: "Treaty", definition: "A special promise or agreement made between groups of people, like First Nations and the government." },
            { term: "Settlement", definition: "A community or place where people build homes and live." },
            { term: "Province", definition: "A large area in Canada, like Alberta, that has its own government." },
            { term: "Physical region", definition: "A big area of land that has special features, like mountains or plains." },
            { term: "Map", definition: "A drawing that shows where places are on Earth." },
            { term: "Bodies of Water", definition: "Large areas of water, like lakes and rivers, that help define physical regions." },
            { term: "Farmland", definition: "Land used for growing crops or raising animals, which the government offered to settlers for a low price." },
            { term: "Natural Landmark", definition: "A special feature created by nature, like a mountain or a rock formation, that is easy to recognize like the Big Rock in Alberta or the Three Sisters in Canmore" },
        ];

        // Constants
        const ALIEN_HORIZONTAL_STEP = 15; // How far the aliens move horizontally per step
        const ALIEN_DROP_STEP = 20;     // How far the aliens drop vertically per reversal
        const ALIEN_TEXT_SIZE = 16;
        const ALIEN_LINE_SPACING = 1.2; // Multiplier for vertical text spacing
        const MIN_ALIEN_WIDTH = 50;
        const MIN_ALIEN_HEIGHT = 20;
        const ALIEN_PADDING_X = 20;
        const PLAYER_SPEED = 5;
        const BULLET_SPEED = 7;
        const MAX_LIVES = 3;
        const RESPAWN_DELAY = 100; // frames
        const MAX_ALIENS_ON_SCREEN = 4; // Max number of choices
       
        // Difficulty settings (Interval in milliseconds between steps)
        const DIFFICULTY_SETTINGS = {
            EASY: 1500,     // 1.5 seconds per step
            MEDIUM: 1000,    // 1 second per step
            CHALLENGE: 500  // 0.5 seconds per step
        };

        // DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const definitionBox = document.getElementById('definition-box');
        const easyButton = document.getElementById('easyButton');
        const mediumButton = document.getElementById('mediumButton');
        const challengeButton = document.getElementById('challengeButton');
        const retryButton = document.getElementById('retryButton');
        const messageOverlay = document.getElementById('message-overlay');
        const messageText = document.getElementById('message-text');
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');

        // Game State Variables
        let gameRunning = false;
        let score = 0;
        let lives = MAX_LIVES;
        let lastTimestamp = 0;
        let playerRespawning = false;
        let respawnTimer = 0;
       
        // New Movement State Variables
        let alienDirection = 1; // 1 for right, -1 for left
        let lastAlienMoveTime = 0;
        let alienMoveInterval = DIFFICULTY_SETTINGS.EASY; // Starts at Easy default
        let baseAlienInterval = DIFFICULTY_SETTINGS.EASY; // Stores the starting interval for the current difficulty
                // --- MULTI-LINE LOGIC ---
                this.lines = term.split(' ');

                let maxLineWidth = 0;
                this.lines.forEach(line => {
                    maxLineWidth = Math.max(maxLineWidth, ctx.measureText(line).width);
                });

                const lineHeight = ALIEN_TEXT_SIZE * ALIEN_LINE_SPACING;
                const requiredTextHeight = this.lines.length * lineHeight;

                // Set Dimensions based on multi-line text
                this.width = Math.max(maxLineWidth + ALIEN_PADDING_X, MIN_ALIEN_WIDTH);
                let startY = this.y - (lineHeight * (this.lines.length - 1)) / 2;

                this.lines.forEach((line, index) => {
                    ctx.fillText(line, this.x, startY + index * lineHeight);
                });
            }
           
            // NOTE: Alien update is now handled by the global update loop for step movement
            update() {
                // No per-frame vertical movement, now controlled by step movement in gameLoop
            }
        }

        // --- GAME FUNCTIONS ---

        function initGame() {
            // Set canvas size to be responsive up to max width
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Initial setup
            score = 0;
            lives = MAX_LIVES;
            gameRunning = false;
           
            updateDisplay();
            setupPlayer();
            resetChallenge(DIFFICULTY_SETTINGS.EASY); // Set initial challenge layout, default to easy interval

            // Setup input listeners only once
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
           
            // Difficulty buttons
            easyButton.addEventListener('click', () => startGame(DIFFICULTY_SETTINGS.EASY));
            mediumButton.addEventListener('click', () => startGame(DIFFICULTY_SETTINGS.MEDIUM));
            challengeButton.addEventListener('click', () => startGame(DIFFICULTY_SETTINGS.CHALLENGE));
            retryButton.addEventListener('click', () => startGame(baseAlienInterval)); // Use the last chosen difficulty

            // Mobile controls
            leftButton.addEventListener('touchstart', (e) => { e.preventDefault(); keys.ArrowLeft = true; });
            leftButton.addEventListener('touchend', (e) => { e.preventDefault(); keys.ArrowLeft = false; });
            rightButton.addEventListener('touchstart', (e) => { e.preventDefault(); keys.ArrowRight = true; });
            rightButton.addEventListener('touchend', (e) => { e.preventDefault(); keys.ArrowRight = false; });
            // Add a dedicated fire trigger for touch devices (tapping the canvas)
            canvas.addEventListener('click', () => { if (gameRunning && !playerRespawning) player.shoot(); });
        }

        function resizeCanvas() {
            const container = canvas.closest('.game-container');
            const containerWidth = container.clientWidth - 20; // Padding adjustment
           
            // Set max width constraint
            const newWidth = Math.min(containerWidth, 600);
           
            canvas.width = newWidth;
            canvas.height = newWidth * (2/3); // Maintain aspect ratio
           
            // Re-center player on resize
            if (player.x !== undefined) {
                 player.x = (canvas.width / 2) - (player.width / 2);
                 player.y = canvas.height - player.height - 10;
            }
        }

        function setupPlayer() {
            player = new Player(
                canvas.width / 2 - 20,
                canvas.height - 10 - 10
            );
        }

        function startGame(interval) {
            if (gameRunning) return;

            messageOverlay.style.display = 'none';
            score = 0;
            lives = MAX_LIVES;
           
            // Set the current and base interval for the selected difficulty
            baseAlienInterval = interval;
            alienMoveInterval = baseAlienInterval;
           
            bullets = [];
            aliens = [];
            playerRespawning = false;
           
            setupPlayer();
            resetChallenge(alienMoveInterval);
            updateDisplay();
           
            gameRunning = true;
            lastAlienMoveTime = performance.now(); // Initialize timer
            requestAnimationFrame(gameLoop);
        }

        function endGame(message) {
            gameRunning = false;
            messageText.textContent = message;
            messageOverlay.style.display = 'flex';
        }

        function updateDisplay() {
            scoreDisplay.textContent = score;
            livesDisplay.textContent = lives;
            definitionBox.textContent = currentChallenge.definition || "Shoot the word that matches the definition!";
        }

        function resetChallenge() {
            // 1. Select the correct vocabulary pair
            const correctPairIndex = Math.floor(Math.random() * VOCABULARY.length);
            currentChallenge = VOCABULARY[correctPairIndex];

            // 2. Select MAX_ALIENS_ON_SCREEN - 1 incorrect terms
            let incorrectPairs = VOCABULARY.filter((_, index) => index !== correctPairIndex);
            incorrectPairs.sort(() => 0.5 - Math.random());
            const choicePool = [currentChallenge.term, ...incorrectPairs.slice(0, MAX_ALIENS_ON_SCREEN - 1).map(p => p.term)];
           
            // 3. Shuffle the choices and create the new aliens array
            choicePool.sort(() => 0.5 - Math.random());
            aliens = [];

            // Calculate slot size required for even spacing
            const numChoices = Math.min(MAX_ALIENS_ON_SCREEN, choicePool.length);
            const alienSpacingX = canvas.width / numChoices;
            const startX = alienSpacingX / 2; // Center of the first slot
           
            let alienIndex = 0;
            const startingY = 30; // Consistent start height

            for (let i = 0; i < numChoices; i++) {
                const term = choicePool[alienIndex];
                const isCorrect = term === currentChallenge.term;
               
                const x = startX + i * alienSpacingX;
               
                // Create Alien at its center position (x is now the center)
                aliens.push(new Alien(x, startingY, term, isCorrect));
                alienIndex++;
            }
           
            // Gradual increase in difficulty by decreasing the interval (making it faster)
            // Capped at 300ms for Challenge level (baseAlienInterval will be 500ms)
            alienMoveInterval = Math.max(300, alienMoveInterval - 50);
           
            // Reset direction for the new round
            alienDirection = 1;

            // Ensure the definition display is updated
            updateDisplay();
        }

        // --- INPUT HANDLERS ---
        function handleKeyDown(event) {
            if (!gameRunning) return;
           
            // Check for movement keys
            if (event.code === 'ArrowLeft' || event.code === 'ArrowRight') {
                keys[event.code] = true;
            }

            // Check for spacebar (shoot)
            if (event.code === 'Space') {
                event.preventDefault(); // Prevent scrolling the page
                if (!playerRespawning) player.shoot();
            }
        }

        function handleKeyUp(event) {
            if (event.code === 'ArrowLeft' || event.code === 'ArrowRight') {
                keys[event.code] = false;
            }
        }

        // --- GAME LOOP & UPDATES ---

        function update(timestamp) {
            if (playerRespawning) {
                respawnTimer++;
                if (respawnTimer > RESPAWN_DELAY) {
                    playerRespawning = false;
                    respawnTimer = 0;
                }
            }

            player.update();

            // 1. Alien Step Movement Logic (Classic Space Invaders)
            if (gameRunning && timestamp - lastAlienMoveTime > alienMoveInterval) {
                let shouldDrop = false;
               
                // Check if any alien hit the boundary
                for (const alien of aliens) {
                    // Check edge based on alien's current position + next step
                    const nextX = alien.x + alienDirection * ALIEN_HORIZONTAL_STEP;
                    const leftEdge = nextX - alien.width / 2;
                    const rightEdge = nextX + alien.width / 2;

                    // 10 pixels margin from the edge
                    if (rightEdge >= canvas.width - 10 || leftEdge <= 10) {
                        shouldDrop = true;
                        break;
                    }
                }

                // Move or Drop
                if (shouldDrop) {
                    alienDirection *= -1; // Reverse direction
                    aliens.forEach(alien => {
                        alien.y += ALIEN_DROP_STEP;
                    });
                } else {
                    // Horizontal move
                    aliens.forEach(alien => {
                        alien.x += alienDirection * ALIEN_HORIZONTAL_STEP;
                    });
                }

                lastAlienMoveTime = timestamp;
               
                // Check for Game Over condition after drop (Invader reached bottom)
                // If any alien's bottom edge crosses the danger zone (above the player cannon)
                const dangerLine = canvas.height - player.height - player.cannonHeight - 10;
               
                for (let i = aliens.length - 1; i >= 0; i--) {
                    const alien = aliens[i];
                    if (alien.y + alien.height / 2 > dangerLine) {
                        // Game Over due to base breach
                        lives = 0;
                        endGame(`BASE BREACH! The invaders passed the line! Final Score: ${score}`);
                        return;
                    }
                }
            }
            // End of Step Movement Logic

            // 2. Update Bullets (Continuous movement)
            bullets.forEach(bullet => bullet.update());
            bullets = bullets.filter(bullet => bullet.y > 0);

            // 3. Check Bullet-Alien Collisions
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                for (let j = aliens.length - 1; j >= 0; j--) {
                    const alien = aliens[j];

                    // Simple AABB collision detection
                    const collision = bullet.x < alien.x + alien.width/2 &&
                                      bullet.x + bullet.width > alien.x - alien.width/2 &&
                                      bullet.y < alien.y + alien.height/2 &&
                                      bullet.y + bullet.height > alien.y - alien.height/2;

                    if (collision) {
                        bullets.splice(i, 1); // Remove bullet
                       
                        if (alien.isCorrect) {
                            // CORRECT HIT!
                            score += 10;
                            showFeedback("CORRECT!", '#00ffaa');
                            // Clear all invaders and start next challenge
                            aliens = [];
                            resetChallenge();
                        } else {
                            // INCORRECT HIT!
                            score = Math.max(0, score - 5);
                            showFeedback("WRONG TERM!", '#ff0077');
                            // Only remove the incorrect alien to keep the correct option visible
                            aliens.splice(j, 1);
                        }
                       
                        updateDisplay();
                        // Exit inner loop since bullet is gone
                        break;
                    }
                }
            }

            // 4. Check Alien-Player Collision (No longer needed due to Base Breach check, but kept for robustness)
            // Removed original logic as 'Base Breach' handles the loss condition more cleanly.
           
            // 5. If all current invaders are cleared, reset the challenge.
            if (aliens.length === 0 && gameRunning) {
                 if (currentChallenge.term) {
                    resetChallenge();
                 }
            }
        }

        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#1a1f25';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw player
            if (gameRunning && (!playerRespawning || respawnTimer % 10 < 5)) {
                player.draw();
            update(timestamp);
            draw();

            requestAnimationFrame(gameLoop);
        }

        // --- INITIALIZATION ---
        window.onload = function() {
            initGame();
        }
    </script>
</body>
</html>
