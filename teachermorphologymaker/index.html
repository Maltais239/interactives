<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Morpheme Game Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito+Sans:wght@400;700;900&display.swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Nunito Sans', sans-serif;
            background-color: #F0F4F8;
            background-image:
                linear-gradient(rgba(255, 255, 255, .8), rgba(255, 255, 255, .8)),
                url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='40' viewBox='0 0 40 40'%3E%3Cg fill-rule='evenodd'%3E%3Cg fill='%239C92AC' fill-opacity='0.1'%3E%3Cpath d='M0 38.59l2.83-2.83 1.41 1.41L1.41 40H0v-1.41zM0 1.4l2.83 2.83 1.41-1.41L1.41 0H0v1.41zM38.59 40l-2.83-2.83 1.41 1.41L40 38.59V40h-1.41zM40 1.41l-2.83 2.83-1.41-1.41L38.59 0H40v1.41zM20 18.6l2.83-2.83 1.41 1.41L21.41 20l2.83 2.83-1.41 1.41L20 21.41l-2.83 2.83-1.41-1.41L18.59 20l-2.83-2.83 1.41-1.41L20 18.59z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
        }
        .glass-container {
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease-in-out;
        }
        /* Builder Styles */
        .builder-label { display: block; margin-bottom: 0.5rem; font-weight: 700; color: #4a5568; }
        .builder-input { width: 100%; padding: 0.75rem; border-radius: 0.5rem; border: 1px solid #cbd5e0; box-shadow: inset 0 2px 4px rgba(0,0,0,0.05); transition: border-color 0.2s; }
        .builder-input:focus { outline: none; border-color: #a78bfa; box-shadow: 0 0 0 3px rgba(167, 139, 250, 0.3); }
        .builder-note { font-size: 0.875rem; color: #718096; margin-top: 0.25rem; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #6d28d9; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }

        /* Editor Styles */
        .editor-word-card {
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }

        /* Game Styles (Copied) */
        .morpheme-tile { display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 0.75rem; border-radius: 10px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.06); cursor: pointer; user-select: none; transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .morpheme-tile-text { font-size: 1.125rem; line-height: 1.75rem; font-weight: 700; }
        .morpheme-tile-label { font-size: 0.75rem; font-weight: 400; opacity: 0.6; margin-top: 1px; }
        .morpheme-tile:hover { transform: translateY(-3px); box-shadow: 0 8px 12px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05), inset 0 2px 4px rgba(0,0,0,0.06); }
        .morpheme-tile:active { transform: translateY(1px) scale(0.98); box-shadow: inset 0 3px 5px rgba(0,0,0,0.1); }
        .prefix-tile { background: linear-gradient(145deg, #89f7fe 0%, #66a6ff 100%); color: #0039cb; }
        .suffix-tile { background: linear-gradient(145deg, #d4fc79 0%, #96e6a1 100%); color: #205c00; }
        .root-word-tile { height: 100%; justify-content: center; }
        .root-word-tile .morpheme-tile-text { font-size: 2.25rem; font-weight: 900; }
        .root-word-tile .morpheme-tile-label { font-size: 0.875rem; }
        .root-word-tile { background: linear-gradient(145deg, #f8cdda 0%, #b5a8f0 100%); color: #582a72;}
        .found-word { background-color: rgba(255, 255, 255, 0.8); color: #3b82f6; font-weight: 700; padding: 0.375rem 0.875rem; border-radius: 9999px; font-size: 0.875rem; box-shadow: 0 1px 3px rgba(0,0,0,0.05); border: 1px solid rgba(255,255,255,1); }
        .progress-bar-container { background-color: #e0e7ff; border-radius: 9999px; overflow: hidden; height: 16px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1); }
        .progress-bar { background: linear-gradient(90deg, #a78bfa 0%, #c4b5fd 100%); height: 100%; width: 0%; transition: width 0.5s ease-out; box-shadow: 0 0 10px rgba(167, 139, 250, 0.8); }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
        .shake-anim { animation: shake 0.82s cubic-bezier(.36,.07,.19,.97) both; }
        .confetti-piece { position: fixed; width: 8px; height: 16px; background: #f00; top: -20px; opacity: 0; z-index: 9999; }
        .flex-1 { flex: 1 1 0%; } .flex-1-5 { flex: 1.5 1 0%; } .flex-2 { flex: 2 1 0%; }
        .level-select-btn { background: linear-gradient(145deg, #ffffff 0%, #e6e9f0 100%); color: #4a5568; font-weight: 700; font-size: 1.125rem; padding: 1rem 1.5rem; border-radius: 12px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); border: 1px solid rgba(255, 255, 255, 0.8); cursor: pointer; transition: all 0.2s ease-out; }
        .level-select-btn:hover { transform: translateY(-4px); color: #2c5282; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
    </style>
</head>
<body class="p-2 sm:p-4 flex items-center justify-center min-h-screen">

    <!-- Builder View (Visible by default) -->
    <div id="builderView" class="glass-container max-w-2xl w-full mx-auto p-4 sm:p-8 rounded-3xl shadow-2xl">
        <h2 class="text-3xl font-black text-center text-purple-800 mb-6 tracking-tight">Morpheme Game Generator</h2>
        
        <div>
            <label for="wordListInput" class="builder-label">Paste your list of root words</label>
            <textarea id="wordListInput" class="builder-input" rows="6" placeholder="e.g., care, use, know, happy, appear, like, cover, comfort, normal, thank"></textarea>
            <p class="builder-note">Separate words with commas or new lines.</p>
        </div>
        
        <div id="errorDisplay" class="text-red-600 font-semibold text-center my-4 min-h-[1.5em]"></div>

        <div class="flex flex-col items-center gap-4 pt-4">
            <button id="generateGameBtn" class="w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-8 rounded-full shadow-lg transition-all transform hover:scale-105 flex items-center justify-center gap-2">
                <span id="generateBtnText">Generate Game</span>
                <div id="loadingSpinner" class="loader hidden"></div>
            </button>
            <!-- REMOVED: Button was moved from here -->
        </div>
    </div>

    <!-- Editor View (Hidden by default) -->
    <div id="editorView" class="glass-container max-w-3xl w-full mx-auto p-4 sm:p-8 rounded-3xl shadow-2xl hidden">
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-3xl font-black text-purple-800 tracking-tight">Review & Edit Your Game</h2>
            <button id="backToBuilderFromEditorBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-full shadow-md transition-all">&larr; Back</button>
        </div>

        <div id="editorFormContainer" class="max-h-[60vh] overflow-y-auto pr-2">
            <!-- Cards will be injected here by JS -->
        </div>
        
        <div class="flex flex-col items-center gap-4 pt-6">
            <button id="finalizeBtn" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-8 rounded-full shadow-lg transition-all transform hover:scale-105">
                Finalize & Preview Game
            </button>
        </div>
    </div>

    <!-- Game View (Hidden by default) -->
    <div id="gameView" class="hidden w-full">
        <!-- Level Select Container (part of Game View) -->
        <div id="levelSelectContainer" class="glass-container max-w-2xl w-full mx-auto p-4 sm:p-8 rounded-3xl shadow-2xl">
            <h2 class="text-3xl font-black text-center text-purple-800 mb-6 tracking-tight">Select a Root Word</h2>
            <div id="levelSelectGrid" class="grid grid-cols-2 md:grid-cols-3 gap-4 mb-6">
                <!-- Buttons will be injected here by JS -->
            </div>
            <!-- ADDED: New container for the save button -->
            <div class="flex flex-col items-center gap-4 pt-6 border-t border-purple-100">
                <button id="downloadBtn" class="w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-full shadow-lg transition-all transform hover:scale-105 hidden">
                    Save Student Game (HTML)
                </button>
                <!-- ADDED 'Back to Generator' button -->
                <button id="backToGeneratorFromLevelsBtn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2 px-5 rounded-full shadow-md transition-all">
                    &larr; Back to Generator
                </button>
            </div>
        </div>
        
        <!-- Game Container -->
        <div id="gameContainer" class="glass-container max-w-4xl w-full mx-auto p-4 sm:p-6 rounded-3xl shadow-2xl hidden mt-6">
            <div class="flex justify-between items-center mb-4">
                <button id="backToLevelsBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-full shadow-md transition-all">&larr; Back to Levels</button>
                <h1 class="text-4xl font-black text-indigo-800 tracking-tight">Can I Have a Word?</h1>
                <div class="w-24"></div> <!-- Spacer -->
            </div>
            
            <div class="game-board mb-4 flex flex-col md:flex-row gap-4 min-h-[180px]">
                <div id="prefixes" class="flex-1 bg-black/5 p-3 rounded-xl flex flex-wrap gap-2 justify-center content-center"></div>
                <div id="root" class="flex-1-5 h-full"></div>
                <div id="suffixes" class="flex-2 bg-black/5 p-3 rounded-xl flex flex-wrap gap-2 justify-center content-center"></div>
            </div>

            <div class="bg-white/70 p-3 rounded-xl mb-3 border shadow-inner">
                <div class="flex items-center justify-between">
                    <h2 class="text-2xl font-bold text-gray-800 tracking-wider" id="currentWordDisplay">&nbsp;</h2>
                    <button id="clearBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg transition-colors shadow-sm">Clear</button>
                </div>
            </div>
            <div class="mb-4">
                <div class="progress-bar-container"><div id="progressBar" class="progress-bar"></div></div>
            </div>
            <div class="flex flex-col sm:flex-row justify-center items-center gap-3 mb-2">
                <button id="checkBtn" class="w-full sm:w-auto bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-6 rounded-full shadow-lg transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100">Check Word</button>
            </div>
            <div id="feedback" class="text-center text-lg font-semibold min-h-[1.5em] mb-2">&nbsp;</div>
            <div class="bg-indigo-100/50 p-4 rounded-2xl border">
                <h3 class="font-bold text-lg text-indigo-900 text-center mb-3">Found Words: <span id="wordCounter">0/0</span></h3>
                <div id="foundWords" class="flex flex-wrap justify-center gap-2 min-h-[40px]"></div>
            </div>
        </div>
    </div>
    
    <script>
    // --- GLOBAL STATE ---
    let allWordSets = []; // Will be populated by the API
    let currentWordSet, currentWord = [], foundWords = [];
    
    // --- BUILDER ELEMENTS ---
    const builderView = document.getElementById('builderView');
    const wordListInput = document.getElementById('wordListInput');
    const generateGameBtn = document.getElementById('generateGameBtn');
    const generateBtnText = document.getElementById('generateBtnText');
    const loadingSpinner = document.getElementById('loadingSpinner');
    const errorDisplay = document.getElementById('errorDisplay');
    const downloadBtn = document.getElementById('downloadBtn');

    // --- EDITOR VIEW ELEMENTS (NEW) ---
    const editorView = document.getElementById('editorView');
    const editorFormContainer = document.getElementById('editorFormContainer');
    const finalizeBtn = document.getElementById('finalizeBtn');
    const backToBuilderFromEditorBtn = document.getElementById('backToBuilderFromEditorBtn');

    // --- GAME VIEW ELEMENTS ---
    const gameView = document.getElementById('gameView');
    const levelSelectContainer = document.getElementById('levelSelectContainer');
    const levelSelectGrid = document.getElementById('levelSelectGrid');
    const gameContainer = document.getElementById('gameContainer');
    // ADDED button element
    const backToGeneratorFromLevelsBtn = document.getElementById('backToGeneratorFromLevelsBtn');
    
    // --- GAME ELEMENTS ---
    const prefixesContainer = document.getElementById('prefixes');
    const rootContainer = document.getElementById('root');
    const suffixesContainer = document.getElementById('suffixes');
    const currentWordDisplay = document.getElementById('currentWordDisplay');
    const checkBtn = document.getElementById('checkBtn');
    const clearBtn = document.getElementById('clearBtn');
    const feedbackEl = document.getElementById('feedback');
    const foundWordsContainer = document.getElementById('foundWords');
    const wordCounter = document.getElementById('wordCounter');
    const progressBar = document.getElementById('progressBar');
    const backToLevelsBtn = document.getElementById('backToLevelsBtn');

    // --- API & GENERATION ---
    const apiKey = ""; // API key will be injected by the environment
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

    // This JSON schema tells the AI exactly what format to return
    const responseSchema = {
        "type": "ARRAY",
        "items": {
            "type": "OBJECT",
            "properties": {
                "root": { "type": "STRING" },
                "prefixes": { "type": "ARRAY", "items": { "type": "STRING" } },
                "suffixes": { "type": "ARRAY", "items": { "type": "STRING" } },
                "prefixRedHerrings": { "type": "ARRAY", "items": { "type": "STRING" } },
                "suffixRedHerrings": { "type": "ARRAY", "items": { "type": "STRING" } },
                "validWords": { "type": "ARRAY", "items": { "type": "STRING" } }
            },
            "required": ["root", "validWords"]
        }
    };
    
    // This system prompt guides the AI to be a game designer
    const systemPrompt = `You are an expert lexicographer and educational game designer. Your task is to take a user's list of root words and generate a complete, structured JSON array for a morpheme game.
    
    For each root word provided by the user, you MUST:
    1.  Identify the root word (e.g., 'port').
    2.  Find all common prefixes that attach to it (e.g., 'im', 'ex', 're', 'sup', 'trans').
    3.  Find all common suffixes (e.g., 's', 'ed', 'ing', 'er', 'able').
    4.  Generate a list of 2-3 plausible but incorrect "red herring" prefixes (e.g., 'un', 'de').
    5.  Generate a list of 2-3 plausible but incorrect "red herring" suffixes (e.g., 'ion', 'ive', 'ly').
    6.  List all valid, common English words that can be formed (e.g., 'port', 'ports', 'importer', 'export', 'reported', 'portable').
    
    You MUST return *only* a valid JSON array matching the provided schema, with no other text.
    - 'prefixes' and 'suffixes' should be the *actual* morphemes.
    - 'prefixRedHerrings' and 'suffixRedHerrings' should be the *decoy* morphemes.
    - 'validWords' must be a comprehensive list.
    - If a word has no common prefixes, return an empty array for 'prefixes'.
    - Always include the root word itself in 'validWords' if it's a valid word.`;

    // --- Helper function to parse CSV input ---
    function parseCsvInput(str) {
        if (!str) return [];
        // Handle spaces, newlines, and commas
        return str.split(/[\s,,\n]+/).map(s => s.trim().toLowerCase()).filter(Boolean);
    }

    generateGameBtn.addEventListener('click', async () => {
        const wordList = wordListInput.value;
        if (!wordList) {
            errorDisplay.textContent = "Please paste in a list of words.";
            return;
        }
        
        // --- UI Loading State ---
        errorDisplay.textContent = "";
        generateBtnText.textContent = "Generating...";
        loadingSpinner.classList.remove('hidden');
        generateGameBtn.disabled = true;
        downloadBtn.classList.add('hidden');

        const userQuery = `Please generate the morpheme game data for the following list of root words: ${wordList}`;

        const payload = {
            contents: [{ parts: [{ text: userQuery }] }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: responseSchema
            }
        };

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`API error! Status: ${response.status}`);
            }

            const result = await response.json();
            
            if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0].text) {
                const jsonText = result.candidates[0].content.parts[0].text;
                const generatedData = JSON.parse(jsonText);
                // NEW: Call populateEditor instead of initializeGameFromData
                populateEditor(generatedData);
                builderView.classList.add('hidden');
                editorView.classList.remove('hidden');
            } else {
                throw new Error("Invalid response structure from API.");
            }

        } catch (err) {
            console.error(err);
            errorDisplay.textContent = `Error generating game: ${err.message}. Please try again.`;
        } finally {
            // --- UI Idle State ---
            generateBtnText.textContent = "Generate Game";
            loadingSpinner.classList.add('hidden');
            generateGameBtn.disabled = false;
        }
    });

    // --- NEW: Editor Functions ---
    function populateEditor(generatedData) {
        editorFormContainer.innerHTML = ""; // Clear previous edits
        generatedData.forEach((wordSet, index) => {
            const card = document.createElement('div');
            card.className = 'editor-word-card';
            // We use data-index to find this card later
            card.dataset.index = index;

            card.innerHTML = `
                <h3 class="text-2xl font-bold text-purple-700 mb-3">${wordSet.root}</h3>
                <input type="hidden" id="root-${index}" value="${wordSet.root}">
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="prefixes-${index}" class="builder-label">Prefixes</label>
                        <input type="text" id="prefixes-${index}" class="builder-input" value="${(wordSet.prefixes || []).join(', ')}">
                    </div>
                    <div>
                        <label for="suffixes-${index}" class="builder-label">Suffixes</label>
                        <input type="text" id="suffixes-${index}" class="builder-input" value="${(wordSet.suffixes || []).join(', ')}">
                    </div>
                    <div>
                        <label for="prefixHerrings-${index}" class="builder-label">Prefix Red Herrings</label>
                        <input type="text" id="prefixHerrings-${index}" class="builder-input" value="${(wordSet.prefixRedHerrings || []).join(', ')}">
                    </div>
                    <div>
                        <label for="suffixHerrings-${index}" class="builder-label">Suffix Red Herrings</label>
                        <input type="text" id="suffixHerrings-${index}" class="builder-input" value="${(wordSet.suffixRedHerrings || []).join(', ')}">
                    </div>
                </div>
                <div>
                    <label for="validWords-${index}" class="builder-label">Valid Words (THIS IS WHERE YOU ADD 'misuse')</label>
                    <textarea id="validWords-${index}" class="builder-input" rows="4" placeholder="e.g., use, misuse, useful, useless">${(wordSet.validWords || []).join(', ')}</textarea>
                    <p class="builder-note">Separate all words with commas or spaces.</p>
                </div>
            `;
            editorFormContainer.appendChild(card);
        });
    }

    finalizeBtn.addEventListener('click', () => {
        const newAllWordSets = [];
        const editorCards = editorFormContainer.querySelectorAll('.editor-word-card');
        
        editorCards.forEach(card => {
            const index = card.dataset.index;
            const newWordSet = {
                root: document.getElementById(`root-${index}`).value,
                prefixes: parseCsvInput(document.getElementById(`prefixes-${index}`).value),
                suffixes: parseCsvInput(document.getElementById(`suffixes-${index}`).value),
                prefixRedHerrings: parseCsvInput(document.getElementById(`prefixHerrings-${index}`).value),
                suffixRedHerrings: parseCsvInput(document.getElementById(`suffixHerrings-${index}`).value),
                validWords: parseCsvInput(document.getElementById(`validWords-${index}`).value)
            };
            newAllWordSets.push(newWordSet);
        });

        // Now, initialize the game with the *edited* data
        initializeGameFromData(newAllWordSets);

        // Show the game view
        editorView.classList.add('hidden');
        gameView.classList.remove('hidden');
        levelSelectContainer.classList.remove('hidden');
        gameContainer.classList.add('hidden');
        
        // Show the download button
        downloadBtn.classList.remove('hidden');
    });

    backToBuilderFromEditorBtn.addEventListener('click', () => {
        editorView.classList.add('hidden');
        builderView.classList.remove('hidden');
    });
    
    function initializeGameFromData(generatedData) {
        allWordSets = generatedData; // Save the data globally
        levelSelectGrid.innerHTML = ""; // Clear old levels
        
        // Create the level select buttons
        allWordSets.forEach((wordSet, index) => {
            const btn = document.createElement('button');
            btn.className = 'level-select-btn';
            btn.textContent = wordSet.root;
            btn.addEventListener('click', () => {
                initGame(allWordSets[index]);
                levelSelectContainer.classList.add('hidden');
                gameContainer.classList.remove('hidden');
            });
            levelSelectGrid.appendChild(btn);
        });
        
        // Show the game view
        builderView.classList.add('hidden');
        gameView.classList.remove('hidden');
        levelSelectContainer.classList.remove('hidden');
        gameContainer.classList.add('hidden');
        
        // Show the download button
        // This is now handled by the finalizeBtn listener
        // downloadBtn.classList.remove('hidden');
    }
    
    downloadBtn.addEventListener('click', () => {
        const jsonData = JSON.stringify(allWordSets, null, 2);
        const htmlContent = createHtmlFileTemplate(jsonData);
        const blob = new Blob([htmlContent], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'student_morpheme_game.html';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    });

    // ADDED event listener for the new 'Back to Generator' button
    backToGeneratorFromLevelsBtn.addEventListener('click', () => {
        gameView.classList.add('hidden');
        builderView.classList.remove('hidden');
        // Hide download button when going all the way back
        downloadBtn.classList.add('hidden');
    });

    /* REMOVED FAULTY EVENT LISTENER
    backToBuilderBtn.addEventListener('click', () => {
        gameView.classList.add('hidden');
        builderView.classList.remove('hidden');
        // Hide download button when going all the way back
        downloadBtn.classList.add('hidden');
    });
    */

    // --- GAME LOGIC FUNCTIONS (Copied from previous file) ---

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function createMorphemeButton(text, type) {
        const btn = document.createElement('div');
        btn.className = 'morpheme-tile';
        const textSpan = document.createElement('span');
        textSpan.className = 'morpheme-tile-text';
        textSpan.textContent = text;
        const labelSpan = document.createElement('span');
        labelSpan.className = 'morpheme-tile-label';

        if (type === 'prefix') { btn.classList.add('prefix-tile'); labelSpan.textContent = 'prefix'; } 
        else if (type === 'suffix') { btn.classList.add('suffix-tile'); labelSpan.textContent = 'suffix'; }
        else if (type === 'root') { btn.classList.add('root-word-tile'); labelSpan.textContent = 'root'; }
        
        btn.appendChild(textSpan); btn.appendChild(labelSpan);
        btn.dataset.type = type;
        btn.addEventListener('click', () => addMorpheme(text, type));
        return btn;
    }

    function addMorpheme(text, type) {
        const lastPart = currentWord.length > 0 ? currentWord[currentWord.length - 1].type : null;
        if (type === 'prefix' && currentWord.length === 0) { currentWord.push({ type, text }); } 
        else if (type === 'root' && (lastPart === 'prefix' || lastPart === null)) { currentWord.push({ type, text }); } 
        else if (type === 'suffix' && (lastPart === 'root' || lastPart === 'suffix')) { currentWord.push({ type, text }); }
        updateCurrentWordDisplay();
    }
    
    // MODIFIED: This function now also uses the smart spelling rules!
    function updateCurrentWordDisplay() { 
        currentWordDisplay.textContent = currentWord.length > 0 ? buildWordFromMorphemes(currentWord) : '\u00A0'; 
    }
    
    function clearCurrentWord() { currentWord = []; updateCurrentWordDisplay(); feedbackEl.innerHTML = '&nbsp;'; }
    
    // REPLACED checkWord to use the new buildWordFromMorphemes function
    function checkWord() {
        // const wordToCheck = currentWord.map(part => part.text).join('').toLowerCase(); // OLD
        const wordToCheck = buildWordFromMorphemes(currentWord); // NEW
        
        if (wordToCheck === '') return;
        feedbackEl.classList.remove('shake-anim');
        void feedbackEl.offsetWidth;
        if (currentWordSet.validWords.includes(wordToCheck)) {
            if (foundWords.includes(wordToCheck)) {
                feedbackEl.textContent = "Already found!";
                feedbackEl.className = 'text-center text-lg font-semibold text-amber-600';
            } else {
                feedbackEl.textContent = "Excellent!";
                feedbackEl.className = 'text-center text-lg font-semibold text-green-600';
                foundWords.push(wordToCheck);
                renderFoundWords();
            }
        } else {
            feedbackEl.textContent = "Not a valid word.";
            feedbackEl.className = 'text-center text-lg font-semibold text-red-600 shake-anim';
        }
        clearCurrentWord();
    }

    // --- ADDED NEW FUNCTION: buildWordFromMorphemes ---
    // This function applies common English spelling rules when building a word from parts.
    function buildWordFromMorphemes(parts) {
        if (parts.length === 0) return "";

        let rootPart = parts.find(p => p.type === 'root');
        
        // Fallback for cases with no root (like just a prefix, shouldn't happen)
        if (!rootPart) return parts.map(p => p.text).join('').toLowerCase();

        let word = rootPart.text;
        let prefixes = parts.filter(p => p.type === 'prefix').map(p => p.text);
        let suffixes = parts.filter(p => p.type === 'suffix').map(p => p.text);

        // Apply suffixes first, as they modify the root's spelling
        suffixes.forEach(suffix => {
            let root = word; // The word *before* adding this suffix
            let originalRootLength = root.length;

            // Rule 1: 'y' to 'i' (e.g., happy + ness -> happiness)
            // Only if root ends in 'y' preceded by a consonant
            if (root.endsWith('y') && suffix[0] !== 'i') {
                const lastChar = root[root.length - 2];
                if (lastChar && !['a', 'e', 'i', 'o', 'u'].includes(lastChar)) {
                     word = root.slice(0, -1) + 'i';
                }
            }
            
            // Rule 2: Drop silent 'e' (e.g., care + ed -> cared, use + ing -> using)
            // Only if suffix starts with a vowel
            else if (root.endsWith('e') && ['a', 'e', 'i', 'o', 'u'].includes(suffix[0])) {
                word = root.slice(0, -1);
            }
            
            // Rule 3: Consonant Doubling (e.g., stop + ed -> stopped)
            // Apply CVC (Consonant-Vowel-Consonant) rule
            else if (root.length >= 2 && ['a', 'e', 'i', 'o', 'u'].includes(suffix[0])) {
                const vowels = ['a', 'e', 'i', 'o', 'u'];
                const last = root[root.length - 1];
                const secondLast = root[root.length - 2];
                const thirdLast = root.length >= 3 ? root[root.length - 3] : null;

                // Check for CVC pattern
                const isLastConsonant = !vowels.includes(last) && last !== 'y' && last !== 'w' && last !== 'x';
                const isSecondLastVowel = vowels.includes(secondLast);
                // Check for start of word OR consonant
                const isThirdLastConsonant = !thirdLast || !vowels.includes(thirdLast); 

                if (isLastConsonant && isSecondLastVowel && isThirdLastConsonant) {
                    word = root + last; // Double the last consonant
                }
            }

            word = word + suffix;
        });

        // Add prefixes at the beginning (they don't change spelling)
        word = prefixes.join('') + word;

        return word.toLowerCase();
    }
    
    function renderFoundWords() {
        foundWordsContainer.innerHTML = '';
        foundWords.sort().forEach(word => {
            const wordEl = document.createElement('span');
            wordEl.className = 'found-word';
            wordEl.textContent = word;
            foundWordsContainer.appendChild(wordEl);
        });
        const progress = (currentWordSet.validWords.length > 0) ? (foundWords.length / currentWordSet.validWords.length) * 100 : 0;
        progressBar.style.width = `${progress}%`;
        wordCounter.textContent = `${foundWords.length}/${currentWordSet.validWords.length}`;
        if (foundWords.length === currentWordSet.validWords.length && currentWordSet.validWords.length > 0) {
            feedbackEl.textContent = "Level Complete!";
            feedbackEl.className = 'text-center text-lg font-semibold text-purple-700';
            checkBtn.disabled = true;
            triggerConfetti();
        }
    }
    
    function initGame(wordSet) {
        currentWordSet = wordSet;
        clearCurrentWord();
        foundWords = [];
        prefixesContainer.innerHTML = ''; rootContainer.innerHTML = ''; suffixesContainer.innerHTML = '';
        
        const allPrefixes = (currentWordSet.prefixes || []).concat(currentWordSet.prefixRedHerrings || []);
        shuffleArray(allPrefixes);
        allPrefixes.forEach(p => prefixesContainer.appendChild(createMorphemeButton(p, 'prefix')));
        
        rootContainer.appendChild(createMorphemeButton(currentWordSet.root, 'root'));

        const allSuffixes = (currentWordSet.suffixes || []).concat(currentWordSet.suffixRedHerrings || []);
        shuffleArray(allSuffixes);
        allSuffixes.forEach(s => suffixesContainer.appendChild(createMorphemeButton(s, 'suffix')));

        checkBtn.disabled = false;
        feedbackEl.innerHTML = '&nbsp;';
        renderFoundWords();
    }

    function showLevelSelect() {
        gameContainer.classList.add('hidden');
        levelSelectContainer.classList.remove('hidden');
    }

    function triggerConfetti() {
        for (let i = 0; i < 100; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti-piece';
            const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800'];
            confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.left = Math.random() * 100 + 'vw';
            confetti.style.animation = `fall ${Math.random() * 2 + 3}s linear ${Math.random() * 2}s forwards`;
            document.body.appendChild(confetti);
            setTimeout(() => { confetti.remove(); }, 5000);
        }
    }
    
    const style = document.createElement('style');
    style.innerHTML = `@keyframes fall { to { transform: translateY(110vh) rotateZ(${Math.random() * 720}deg); opacity: 1; } }`;
    document.head.appendChild(style);
    
    // --- Game Event Listeners ---
    checkBtn.addEventListener('click', checkWord);
    clearBtn.addEventListener('click', clearCurrentWord);
    backToLevelsBtn.addEventListener('click', showLevelSelect);

    // --- HTML File Template Function ---
    // This creates the full HTML for the downloadable student game
    
    function createHtmlFileTemplate(jsonData) {
        // This template is the *exact* student game file from our previous conversation,
        // but it injects the new JSON data.
        return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Your Custom Morpheme Game</title>
    <script src="https://cdn.tailwindcss.com"><\/script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito+Sans:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Nunito Sans', sans-serif; background-color: #F0F4F8; background-image: linear-gradient(rgba(255, 255, 255, .8), rgba(255, 255, 255, .8)), url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='40' viewBox='0 0 40 40'%3E%3Cg fill-rule='evenodd'%3E%3Cg fill='%239C92AC' fill-opacity='0.1'%3E%3Cpath d='M0 38.59l2.83-2.83 1.41 1.41L1.41 40H0v-1.41zM0 1.4l2.83 2.83 1.41-1.41L1.41 0H0v1.41zM38.59 40l-2.83-2.83 1.41 1.41L40 38.59V40h-1.41zM40 1.41l-2.83 2.83-1.41-1.41L38.59 0H40v1.41zM20 18.6l2.83-2.83 1.41 1.41L21.41 20l2.83 2.83-1.41 1.41L20 21.41l-2.83 2.83-1.41-1.41L18.59 20l-2.83-2.83 1.41-1.41L20 18.59z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"); }
        .glass-container { background: rgba(255, 255, 255, 0.6); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.3); transition: all 0.3s ease-in-out; }
        .morpheme-tile { display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 0.75rem; border-radius: 10px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.06); cursor: pointer; user-select: none; transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .morpheme-tile-text { font-size: 1.125rem; line-height: 1.75rem; font-weight: 700; }
        .morpheme-tile-label { font-size: 0.75rem; font-weight: 400; opacity: 0.6; margin-top: 1px; }
        .morpheme-tile:hover { transform: translateY(-3px); box-shadow: 0 8px 12px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05), inset 0 2px 4px rgba(0,0,0,0.06); }
        .morpheme-tile:active { transform: translateY(1px) scale(0.98); box-shadow: inset 0 3px 5px rgba(0,0,0,0.1); }
        .prefix-tile { background: linear-gradient(145deg, #89f7fe 0%, #66a6ff 100%); color: #0039cb; }
        .suffix-tile { background: linear-gradient(145deg, #d4fc79 0%, #96e6a1 100%); color: #205c00; }
        .root-word-tile { height: 100%; justify-content: center; font-size: 2.25rem; font-weight: 900; }
        .root-word-tile .morpheme-tile-label { font-size: 0.875rem; }
        .root-word-tile { background: linear-gradient(145deg, #f8cdda 0%, #b5a8f0 100%); color: #582a72;}
        .found-word { background-color: rgba(255, 255, 255, 0.8); color: #3b82f6; font-weight: 700; padding: 0.375rem 0.875rem; border-radius: 9999px; font-size: 0.875rem; box-shadow: 0 1px 3px rgba(0,0,0,0.05); border: 1px solid rgba(255,255,255,1); }
        .progress-bar-container { background-color: #e0e7ff; border-radius: 9999px; overflow: hidden; height: 16px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1); }
        .progress-bar { background: linear-gradient(90deg, #a78bfa 0%, #c4b5fd 100%); height: 100%; width: 0%; transition: width 0.5s ease-out; box-shadow: 0 0 10px rgba(167, 139, 250, 0.8); }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
        .shake-anim { animation: shake 0.82s cubic-bezier(.36,.07,.19,.97) both; }
        .confetti-piece { position: fixed; width: 8px; height: 16px; background: #f00; top: -20px; opacity: 0; z-index: 9999; }
        .flex-1 { flex: 1 1 0%; } .flex-1-5 { flex: 1.5 1 0%; } .flex-2 { flex: 2 1 0%; }
        .level-select-btn { background: linear-gradient(145deg, #ffffff 0%, #e6e9f0 100%); color: #4a5568; font-weight: 700; font-size: 1.125rem; padding: 1rem 1.5rem; border-radius: 12px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); border: 1px solid rgba(255, 255, 255, 0.8); cursor: pointer; transition: all 0.2s ease-out; }
        .level-select-btn:hover { transform: translateY(-4px); color: #2c5282; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
    </style>
</head>
<body class="p-2 sm:p-4 flex items-center justify-center min-h-screen">
    <div id="levelSelectContainer" class="glass-container max-w-2xl w-full mx-auto p-4 sm:p-8 rounded-3xl shadow-2xl">
        <h2 class="text-3xl font-black text-center text-purple-800 mb-6 tracking-tight">Select a Root Word</h2>
        <div id="levelSelectGrid" class="grid grid-cols-2 md:grid-cols-3 gap-4"></div>
    </div>
    <div id="gameContainer" class="glass-container max-w-4xl w-full mx-auto p-4 sm:p-6 rounded-3xl shadow-2xl hidden">
        <div class="flex justify-between items-center mb-4">
             <button id="backToLevelsBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2 px-4 rounded-full shadow-md transition-all">&larr; Back to Levels</button>
             <h1 class="text-4xl font-black text-indigo-800 tracking-tight">Can I Have a Word?</h1>
             <div class="w-24"></div>
        </div>
        <div class="game-board mb-4 flex flex-col md:flex-row gap-4 min-h-[180px]">
            <div id="prefixes" class="flex-1 bg-black/5 p-3 rounded-xl flex flex-wrap gap-2 justify-center content-center"></div>
            <div id="root" class="flex-1-5 h-full"></div>
            <div id="suffixes" class="flex-2 bg-black/5 p-3 rounded-xl flex flex-wrap gap-2 justify-center content-center"></div>
        </div>
        <div class="bg-white/70 p-3 rounded-xl mb-3 border shadow-inner">
            <div class="flex items-center justify-between">
                <h2 class="text-2xl font-bold text-gray-800 tracking-wider" id="currentWordDisplay">&nbsp;</h2>
                <button id="clearBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg transition-colors shadow-sm">Clear</button>
            </div>
        </div>
        <div class="mb-4">
            <div class="progress-bar-container"><div id="progressBar" class="progress-bar"></div></div>
        </div>
        <div class="flex flex-col sm:flex-row justify-center items-center gap-3 mb-2">
            <button id="checkBtn" class="w-full sm:w-auto bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-6 rounded-full shadow-lg transition-all transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:scale-100">Check Word</button>
        </div>
        <div id="feedback" class="text-center text-lg font-semibold min-h-[1.5em] mb-2">&nbsp;</div>
        <div class="bg-indigo-100/50 p-4 rounded-2xl border">
            <h3 class="font-bold text-lg text-indigo-900 text-center mb-3">Found Words: <span id="wordCounter">0/0</span></h3>
            <div id="foundWords" class="flex flex-wrap justify-center gap-2 min-h-[40px]"></div>
        </div>
    </div>
    <script>
    // This is the custom game data generated by the teacher tool!
    const allWordSets = ${jsonData};

    let currentWordSet, currentWord = [], foundWords = [];
    const levelSelectContainer = document.getElementById('levelSelectContainer');
    const levelSelectGrid = document.getElementById('levelSelectGrid');
    const gameContainer = document.getElementById('gameContainer');
    const prefixesContainer = document.getElementById('prefixes');
    const rootContainer = document.getElementById('root');
    const suffixesContainer = document.getElementById('suffixes');
    const currentWordDisplay = document.getElementById('currentWordDisplay');
    const checkBtn = document.getElementById('checkBtn');
    const clearBtn = document.getElementById('clearBtn');
    const feedbackEl = document.getElementById('feedback');
    const foundWordsContainer = document.getElementById('foundWords');
    const wordCounter = document.getElementById('wordCounter');
    const progressBar = document.getElementById('progressBar');
    const backToLevelsBtn = document.getElementById('backToLevelsBtn');
    function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } }
    function createMorphemeButton(text, type) { const btn = document.createElement('div'); btn.className = 'morpheme-tile'; const textSpan = document.createElement('span'); textSpan.className = 'morpheme-tile-text'; textSpan.textContent = text; const labelSpan = document.createElement('span'); labelSpan.className = 'morpheme-tile-label'; if (type === 'prefix') { btn.classList.add('prefix-tile'); labelSpan.textContent = 'prefix'; } else if (type === 'suffix') { btn.classList.add('suffix-tile'); labelSpan.textContent = 'suffix'; } else if (type === 'root') { btn.classList.add('root-word-tile'); labelSpan.textContent = 'root'; } btn.appendChild(textSpan); btn.appendChild(labelSpan); btn.dataset.type = type; btn.addEventListener('click', () => addMorpheme(text, type)); return btn; }
    function addMorpheme(text, type) { const lastPart = currentWord.length > 0 ? currentWord[currentWord.length - 1].type : null; if (type === 'prefix' && currentWord.length === 0) { currentWord.push({ type, text }); } else if (type === 'root' && (lastPart === 'prefix' || lastPart === null)) { currentWord.push({ type, text }); } else if (type === 'suffix' && (lastPart === 'root' || lastPart === 'suffix')) { currentWord.push({ type, text }); } updateCurrentWordDisplay(); }
    function updateCurrentWordDisplay() { currentWordDisplay.textContent = currentWord.length > 0 ? currentWord.map(p => p.text).join('') : '\u00A0'; }
    function clearCurrentWord() { currentWord = []; updateCurrentWordDisplay(); feedbackEl.innerHTML = '&nbsp;'; }
    function checkWord() { const wordToCheck = currentWord.map(part => part.text).join('').toLowerCase(); if (wordToCheck === '') return; feedbackEl.classList.remove('shake-anim'); void feedbackEl.offsetWidth; if (currentWordSet.validWords.includes(wordToCheck)) { if (foundWords.includes(wordToCheck)) { feedbackEl.textContent = "Already found!"; feedbackEl.className = 'text-center text-lg font-semibold text-amber-600'; } else { feedbackEl.textContent = "Excellent!"; feedbackEl.className = 'text-center text-lg font-semibold text-green-600'; foundWords.push(wordToCheck); renderFoundWords(); } } else { feedbackEl.textContent = "Not a valid word."; feedbackEl.className = 'text-center text-lg font-semibold text-red-600 shake-anim'; } clearCurrentWord(); }
    function renderFoundWords() { foundWordsContainer.innerHTML = ''; foundWords.sort().forEach(word => { const wordEl = document.createElement('span'); wordEl.className = 'found-word'; wordEl.textContent = word; foundWordsContainer.appendChild(wordEl); }); const progress = (currentWordSet.validWords.length > 0) ? (foundWords.length / currentWordSet.validWords.length) * 100 : 0; progressBar.style.width = \`\${progress}%\`; wordCounter.textContent = \`\${foundWords.length}/\${currentWordSet.validWords.length}\`; if (foundWords.length === currentWordSet.validWords.length && currentWordSet.validWords.length > 0) { feedbackEl.textContent = "Level Complete!"; feedbackEl.className = 'text-center text-lg font-semibold text-purple-700'; checkBtn.disabled = true; triggerConfetti(); } }
    function initGame(wordSet) { currentWordSet = wordSet; clearCurrentWord(); foundWords = []; prefixesContainer.innerHTML = ''; rootContainer.innerHTML = ''; suffixesContainer.innerHTML = ''; const allPrefixes = (currentWordSet.prefixes || []).concat(currentWordSet.prefixRedHerrings || []); shuffleArray(allPrefixes); allPrefixes.forEach(p => prefixesContainer.appendChild(createMorphemeButton(p, 'prefix'))); rootContainer.appendChild(createMorphemeButton(currentWordSet.root, 'root')); const allSuffixes = (currentWordSet.suffixes || []).concat(currentWordSet.suffixRedHerrings || []); shuffleArray(allSuffixes); allSuffixes.forEach(s => suffixesContainer.appendChild(createMorphemeButton(s, 'suffix'))); checkBtn.disabled = false; feedbackEl.innerHTML = '&nbsp;'; renderFoundWords(); gameContainer.classList.remove('hidden'); levelSelectContainer.classList.add('hidden'); }
    function showLevelSelect() { gameContainer.classList.add('hidden'); levelSelectContainer.classList.remove('hidden'); }
    function triggerConfetti() { for (let i = 0; i < 100; i++) { const confetti = document.createElement('div'); confetti.className = 'confetti-piece'; const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800']; confetti.style.background = colors[Math.floor(Math.random() * colors.length)]; confetti.style.left = Math.random() * 100 + 'vw'; confetti.style.animation = \`fall \${Math.random() * 2 + 3}s linear \${Math.random() * 2}s forwards\`; document.body.appendChild(confetti); setTimeout(() => { confetti.remove(); }, 5000); } }
    const style = document.createElement('style'); style.innerHTML = \`@keyframes fall { to { transform: translateY(110vh) rotateZ(\${Math.random() * 720}deg); opacity: 1; } }\`; document.head.appendChild(style);
    checkBtn.addEventListener('click', checkWord); clearBtn.addEventListener('click', clearCurrentWord); backToLevelsBtn.addEventListener('click', showLevelSelect);
    allWordSets.forEach((wordSet, index) => { const btn = document.createElement('button'); btn.className = 'level-select-btn'; btn.textContent = wordSet.root; btn.addEventListener('click', () => initGame(allWordSets[index])); levelSelectGrid.appendChild(btn); });
    <\/script>
</body>
</html>
        `;
    }
    </script>
</body>
</html>







