<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Science Definition Match: Earth Systems</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;600;700&family=Merriweather:ital,wght@0,300;0,700;1,300&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Earth Systems Palette */
            --bg-gradient-top: #1a2a6c;    /* Deep Space/Ocean Blue */
            --bg-gradient-mid: #b21f1f;    /* Magma/Core Red (Subtle) */
            --bg-gradient-bot: #fdbb2d;    /* Sun/Sand Yellow */
            
            /* Using a cleaner Blue-Teal-Green gradient for the main background */
            --earth-bg: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            
            --panel-glass: rgba(255, 255, 255, 0.95);
            --panel-border: rgba(255, 255, 255, 0.3);
            
            --btn: #2e8b57; /* Sea Green */
            --btn-hover: #3cb371;
            
            --text-main: #2c3e50;
            --text-muted: #546e7a;
            
            --slot-border: #90a4ae;
            --slot-bg: rgba(236, 240, 241, 0.5);
            
            --correct-bg: #d1fae5;
            --correct-border: #059669;
            --incorrect-bg: #fee2e2;
            --incorrect-border: #dc2626;
            
            --shadow-soft: 0 4px 6px rgba(0,0,0,0.1);
            --shadow-deep: 0 10px 25px rgba(0,0,0,0.2);
        }

        * { box-sizing: border-box; }

        body { 
            font-family: 'Montserrat', sans-serif; 
            margin: 0; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: flex-start; 
            min-height: 100vh; 
            background: var(--earth-bg);
            background-attachment: fixed; /* Parallax-like feel */
            padding: 20px; 
            color: #fff;
        }

        h1 { 
            font-family: 'Merriweather', serif;
            font-size: 2.2em; 
            margin-bottom: 0.2em; 
            text-align: center;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            font-weight: 700;
            letter-spacing: 0.5px;
        }
        
        p.subtitle { 
            font-family: 'Montserrat', sans-serif;
            color: #eceff1; 
            margin-bottom: 2em; 
            text-align: center;
            font-weight: 300;
            letter-spacing: 1px;
            opacity: 0.9;
            max-width: 600px;
        }

        .game-container { 
            background: var(--panel-glass); 
            width: 100%; 
            max-width: 900px; 
            padding: 30px; 
            border-radius: 16px; 
            box-shadow: var(--shadow-deep); 
            border: 1px solid var(--panel-border);
            position: relative; 
            color: var(--text-main);
            backdrop-filter: blur(10px); /* Glassmorphism */
            -webkit-backdrop-filter: blur(10px);
        }

        /* --- Term Pool (The "Atmosphere" area) --- */
        #term-pool { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 12px; 
            justify-content: center; 
            padding: 20px; 
            background-color: rgba(236, 240, 241, 0.4); 
            border-radius: 12px; 
            margin-bottom: 30px; 
            min-height: 80px; 
            border: 1px dashed #b0bec5;
        }

        .term-item { 
            padding: 10px 20px; 
            border-radius: 50px; /* Pebble shape */
            cursor: grab; 
            user-select: none; 
            position: relative; 
            font-weight: 600; 
            font-size: 0.95rem;
            color: #fff; 
            touch-action: none; 
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.2s; 
            text-align: center; 
            min-width: 100px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            border: 2px solid rgba(255,255,255,0.2);
        }

        /* --- Earthy Term Colors --- */
        /* Ocean */
        .term-color-1 { background-color: #0277bd; border-color: #01579b; } 
        /* Forest */
        .term-color-2 { background-color: #2e7d32; border-color: #1b5e20; } 
        /* Clay/Magma */
        .term-color-3 { background-color: #c62828; border-color: #b71c1c; } 
        /* Atmosphere/Sky */
        .term-color-4 { background-color: #78909c; border-color: #546e7a; } 
        /* Sand/Desert */
        .term-color-5 { background-color: #f9a825; border-color: #f57f17; } 
        /* Freshwater/Ice */
        .term-color-6 { background-color: #00acc1; border-color: #00838f; } 
        /* Soil/Earth */
        .term-color-7 { background-color: #795548; border-color: #5d4037; } 
        /* Flora */
        .term-color-8 { background-color: #558b2f; border-color: #33691e; } 
        /* Stone/Mountain */
        .term-color-9 { background-color: #546e7a; border-color: #37474f; } 
        /* Sunset/Horizon */
        .term-color-10{ background-color: #ef6c00; border-color: #e65100; } 

        .term-item:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        .term-item:active { cursor: grabbing; }

        .term-item.dragging { 
            opacity: 0.8; 
            cursor: grabbing; 
            position: absolute; 
            z-index: 1000; 
            transform: scale(1.1) rotate(2deg); 
            box-shadow: 0 10px 20px rgba(0,0,0,0.3); 
            transition: none; 
        }
        .term-item.native-dragging { opacity: 0.4; }

        /* --- Definitions Area --- */
        #definitions-area { display: flex; flex-direction: column; gap: 16px; margin-bottom: 30px; }
        
        .definition-row { 
            display: flex; 
            align-items: stretch; 
            gap: 15px; 
            background: #fff;
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            transition: transform 0.2s;
        }
        
        .definition-row:hover { transform: translateX(5px); }

        .term-slot { 
            width: 170px; 
            min-height: 60px; 
            border: 2px dashed var(--slot-border); 
            border-radius: 10px; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            background-color: var(--slot-bg); 
            transition: all 0.3s ease; 
            flex-shrink: 0; 
            position: relative;
        }
        
        /* Inner shadow for empty slot */
        .term-slot:empty::after {
            content: 'Drop Here';
            color: #b0bec5;
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .term-slot.over { 
            background-color: #e0f7fa; 
            border-style: solid; 
            border-color: #00bcd4; 
            transform: scale(1.02);
        }

        /* Style for term dropped into a slot */
        .term-slot .term-item {
            cursor: grab; 
            margin: 0; 
            width: 100%; 
            height: 100%;
            display: flex; 
            justify-content: center; 
            align-items: center; 
            box-shadow: none;
            position: static !important; 
            transform: none !important; 
            opacity: 1 !important;
            border-radius: 8px; /* Slightly less round when docked */
        }

        .definition-text { 
            flex-grow: 1; 
            padding: 5px 10px; 
            display: flex; 
            align-items: center;
            font-size: 0.95em; 
            line-height: 1.5; 
            color: var(--text-main); 
            border-left: 3px solid #eceff1;
        }
        
        /* Feedback Styles */
         .term-slot.correct { 
             border: 2px solid var(--correct-border) !important; 
             background-color: var(--correct-bg) !important;
         }
         .term-slot.correct::after { content: 'âœ“'; color: var(--correct-border); position: absolute; right: -10px; top: -10px; background: white; border-radius: 50%; padding: 2px 6px; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.1); font-size: 0.8rem; display: block; }
         
         .term-slot.incorrect { 
             border: 2px solid var(--incorrect-border) !important; 
             background-color: var(--incorrect-bg) !important; 
         }
         
         .term-item.unplaced { 
             animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
             border: 2px solid #ff9800 !important;
         }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* Controls */
        .controls { 
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 2em;
            padding-top: 20px;
            border-top: 1px solid rgba(0,0,0,0.1);
        }
        
        .controls button { 
            background: var(--btn); 
            color: #fff; 
            border: none; 
            padding: 12px 30px; 
            border-radius: 50px; 
            cursor: pointer; 
            font-size: 1rem; 
            font-weight: 600;
            font-family: 'Montserrat', sans-serif; 
            transition: all 0.3s ease; 
            box-shadow: 0 4px 6px rgba(46, 139, 87, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .controls button:hover { 
            background: var(--btn-hover); 
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(46, 139, 87, 0.4);
        }
        
        #reset-btn {
            background-color: #78909c;
            box-shadow: 0 4px 6px rgba(120, 144, 156, 0.3);
        }
        #reset-btn:hover {
            background-color: #607d8b;
            box-shadow: 0 6px 12px rgba(120, 144, 156, 0.4);
        }
        
        /* Mobile Tweaks */
        @media (max-width: 600px) {
            h1 { font-size: 1.8em; }
            .definition-row { flex-direction: column; gap: 5px; }
            .term-slot { width: 100%; height: 50px; min-height: 50px; }
            .definition-text { border-left: none; padding-top: 0; font-size: 0.9em; color: var(--text-muted); }
            .game-container { padding: 15px; }
        }
    </style>
</head>
<body>
    <h1>Earth Systems Match</h1>
    <p class="subtitle">Connect the components of our planet to their definitions.</p>

    <div class="game-container">
        <!-- Pool of draggable items -->
        <div id="term-pool"></div>

        <!-- List of definitions and slots -->
        <div id="definitions-area"></div>

        <div class="controls">
            <button id="check-btn">Check Answers</button>
            <button id="reset-btn">Reset Board</button>
        </div>
    </div>

    <script>
    /**
     * Definition Matching Game - Earth Systems Theme
     * v7.0
     * - New "Earth Systems" visual design
     * - Glassmorphism UI
     * - Improved touch handling
     * - Accessibility: Montserrat font
     */
    document.addEventListener('DOMContentLoaded', () => {

        const DEFINITIONS = [
             { term: "Earth", definition: "The planet we live on, comprising the geosphere, biosphere, hydrosphere, and atmosphere." },
             { term: "Landform", definition: "A natural feature of the Earth's solid surface, such as a canyon, mountain, or valley." },
             { term: "Mountain", definition: "A large landform that rises above the surrounding land in a limited area, usually in the form of a peak." },
             { term: "Prairie", definition: "A large open area of grassland, representing a key terrestrial biome." },
             { term: "Wetland", definition: "A distinct ecosystem that is flooded by water, either permanently or seasonally." },
             { term: "Ocean", definition: "The continuous body of saltwater that covers more than 70% of the Earth's surface." },
             { term: "Freshwater", definition: "Naturally occurring water on Earth's surface in ice sheets, glaciers, rivers, and lakes." },
             { term: "Saltwater", definition: "Water containing a significant concentration of dissolved salts, found in oceans." },
             { term: "Rotation", definition: "The action of the Earth turning around its axis, causing day and night." },
             { term: "UNESCO Site", definition: "A landmark or area with legal protection by an international convention for its value to humanity." },
        ];

        const termPool = document.getElementById('term-pool');
        const definitionsArea = document.getElementById('definitions-area');
        const gameContainer = document.querySelector('.game-container');

        let draggedTermElement = null;
        let offsetX = 0, offsetY = 0;
        let isTouchDragging = false;

        function initializeGame() {
            termPool.innerHTML = '';
            definitionsArea.innerHTML = '';
            draggedTermElement = null;
            isTouchDragging = false;

            // Create Definition Slots
            const shuffledDefinitions = [...DEFINITIONS].sort(() => Math.random() - 0.5);
            shuffledDefinitions.forEach(item => {
                const row = document.createElement('div'); 
                row.className = 'definition-row';
                
                const slot = document.createElement('div'); 
                slot.className = 'term-slot';
                slot.dataset.correctTerm = item.term;
                addDropZoneListeners(slot); // Add listeners
                
                const definition = document.createElement('div'); 
                definition.className = 'definition-text'; 
                definition.textContent = item.definition;
                
                row.appendChild(slot); 
                row.appendChild(definition); 
                definitionsArea.appendChild(row);
            });

            // Create Draggable Terms
            let terms = DEFINITIONS.map(item => item.term);
            terms.sort(() => Math.random() - 0.5);
            terms.forEach((term, index) => {
                const termEl = document.createElement('div'); 
                termEl.className = 'term-item';
                // Assign specific colors based on the term index (randomized order, but consistent palette distribution)
                termEl.classList.add('term-color-' + ((index % 10) + 1)); 
                
                termEl.draggable = true; 
                termEl.id = `term-${term.toLowerCase().replace(/\s+/g, '-')}-${index}`;
                termEl.dataset.term = term; 
                termEl.textContent = term;
                
                addDraggableListeners(termEl); // Add listeners
                termPool.appendChild(termEl);
            });
        }

        // --- Listener Helper Functions ---
        function addDraggableListeners(element) {
            element.addEventListener('dragstart', handleDragStartTerm);
            element.addEventListener('dragend', handleDragEndTerm);
            element.addEventListener('pointerdown', handlePointerDownTerm);
        }
        function addDropZoneListeners(element) {
            element.addEventListener('dragover', handleDragOverSlot);
            element.addEventListener('dragleave', handleDragLeaveSlot);
            element.addEventListener('drop', handleDropSlot);
        }

        // --- Draggable Term Event Handlers ---
        function handleDragStartTerm(e) { 
            if (e.pointerType === 'touch') { e.preventDefault(); return; } 
            draggedTermElement = e.target; 
            e.dataTransfer.setData('text/term-id', e.target.id); 
            e.dataTransfer.effectAllowed = 'move'; 
            setTimeout(() => { e.target.classList.add('native-dragging'); }, 0); 
            isTouchDragging = false; 
        }
        
        function handleDragEndTerm(e) { 
            if (draggedTermElement && draggedTermElement.classList.contains('term-item')) { 
                draggedTermElement.classList.remove('native-dragging'); 
            } 
            document.querySelectorAll('.term-slot.over').forEach(zone => zone.classList.remove('over')); 
            isTouchDragging = false; 
            draggedTermElement = null; 
            document.body.style.userSelect = ''; 
        }
        
        function handlePointerDownTerm(e) { 
            if (e.button !== 0 || draggedTermElement) return; 
            
            draggedTermElement = e.currentTarget; 
            isTouchDragging = e.pointerType === 'touch'; 
            
            if (isTouchDragging) { 
                e.preventDefault(); 
                draggedTermElement.setPointerCapture(e.pointerId); 
                const rect = draggedTermElement.getBoundingClientRect(); 
                offsetX = e.clientX - rect.left; 
                offsetY = e.clientY - rect.top; 
                draggedTermElement.classList.add('dragging'); 
                handlePointerMoveTerm(e); 
            } else { 
                try { draggedTermElement.setPointerCapture(e.pointerId); } catch (err) {} 
            } 
            
            document.addEventListener('pointermove', handlePointerMoveTerm); 
            document.addEventListener('pointerup', handlePointerUpTerm); 
            document.addEventListener('pointercancel', handlePointerUpTerm); 
            document.body.style.userSelect = 'none'; 
        }
        
        function handlePointerMoveTerm(e) { 
            if (!draggedTermElement || !draggedTermElement.hasPointerCapture(e.pointerId)) return; 
            
            if (isTouchDragging) { 
                e.preventDefault(); 
                const gameRect = gameContainer.getBoundingClientRect(); 
                // Calculate position relative to the container for smoother visual tracking
                let newX = e.clientX - gameRect.left - offsetX; 
                let newY = e.clientY - gameRect.top - offsetY; 
                
                // Allow dragging outside container bounds visually (fixed positioning logic could be used, but absolute relative to container is safer for scrolling)
                draggedTermElement.style.left = `${newX}px`; 
                draggedTermElement.style.top = `${newY}px`; 
            } 
            
            // Hit testing for hover effects
            let elementUnderPointer = null; 
            const originalVisibility = isTouchDragging ? draggedTermElement.style.visibility : ''; 
            
            if (isTouchDragging) { draggedTermElement.style.visibility = 'hidden'; } 
            elementUnderPointer = document.elementFromPoint(e.clientX, e.clientY); 
            if (isTouchDragging) { draggedTermElement.style.visibility = originalVisibility; } 
            
            let currentDropTarget = elementUnderPointer ? elementUnderPointer.closest('.term-slot') : null; 
            document.querySelectorAll('.term-slot.over').forEach(t => t.classList.remove('over')); 
            if(currentDropTarget) { currentDropTarget.classList.add('over'); } 
        }

        // --- Pointer Up - Handles TOUCH drops ---
        function handlePointerUpTerm(e) {
            if (!draggedTermElement || !draggedTermElement.hasPointerCapture(e.pointerId)) {
                 cleanUpDragListeners(); return;
            }
            const currentTermElement = draggedTermElement; 

            // Reset styles
            currentTermElement.classList.remove('dragging');
            currentTermElement.style.left = '';
            currentTermElement.style.top = '';
            
            // Hit test
            currentTermElement.style.visibility = 'hidden'; 
            let elementUnderPointer = document.elementFromPoint(e.clientX, e.clientY);
            let finalDropTarget = elementUnderPointer ? elementUnderPointer.closest('.term-slot') : null;
            currentTermElement.style.visibility = '';

            cleanUpDragListeners();
            document.querySelectorAll('.term-slot.over').forEach(t => t.classList.remove('over'));

            if (isTouchDragging) {
                if (finalDropTarget) { 
                    moveItemToSlot(currentTermElement, finalDropTarget);
                } else { 
                    returnItemToPool(currentTermElement);
                }
            } else { 
                 // Mouse drag end is handled by 'drop' event, just cleanup visual state here
                 currentTermElement.classList.remove('native-dragging');
            }

            try { currentTermElement.releasePointerCapture(e.pointerId); } catch (err) {}
            draggedTermElement = null;
            isTouchDragging = false;
        }

        // --- Drop Slot Event Handlers (Mouse) ---
        function handleDragOverSlot(e) { 
            e.preventDefault(); 
            if (!this.querySelector('.term-item')) { 
                this.classList.add('over'); 
                if (e.dataTransfer) e.dataTransfer.dropEffect = 'move'; 
            } else { 
                if (e.dataTransfer) e.dataTransfer.dropEffect = 'none'; 
            } 
        }
        
        function handleDragLeaveSlot(e) { 
            if (!this.contains(e.relatedTarget)) { this.classList.remove('over'); } 
        }

        function handleDropSlot(e) {
            e.preventDefault();
            const dropSlot = this;
            dropSlot.classList.remove('over');

            if (isTouchDragging || dropSlot.querySelector('.term-item')) { return; }

            const droppedTermId = e.dataTransfer.getData('text/term-id');
            const droppedElement = document.getElementById(droppedTermId);

            if (droppedElement && dropSlot.classList.contains('term-slot')) {
                 moveItemToSlot(droppedElement, dropSlot);
                 droppedElement.classList.remove('native-dragging'); 
            }
            draggedTermElement = null;
        }

        // --- Helper functions for moving items ---
        function returnItemToPool(itemElement) {
            if (itemElement && !termPool.contains(itemElement)) {
                itemElement.style.border = ''; 
                itemElement.classList.remove('unplaced');
                termPool.appendChild(itemElement);
            }
        }

        function moveItemToSlot(itemElement, targetSlot) {
            if (!itemElement || !targetSlot) return;
            // If slot occupied, evict current tenant
            const currentItemInSlot = targetSlot.querySelector('.term-item');
            if (currentItemInSlot && currentItemInSlot !== itemElement) {
                returnItemToPool(currentItemInSlot);
            }
            
            targetSlot.innerHTML = ''; 
            targetSlot.appendChild(itemElement);
            
            itemElement.style.border = '';
            itemElement.classList.remove('unplaced');
            targetSlot.classList.remove('correct', 'incorrect'); 
        }

        // --- Control Button Listeners ---
        document.getElementById('check-btn').addEventListener('click', () => {
             // Reset visual states
             document.querySelectorAll('.term-slot').forEach(slot => {
                 slot.classList.remove('correct', 'incorrect');
                 // Remove old checkmarks if any (CSS pseudo-elements handle visuals, but good to clean logic)
             });
             document.querySelectorAll('.term-item').forEach(item => { 
                 item.classList.remove('unplaced'); 
             });

             let allSlotsFilled = true; 
             let allMatchesCorrect = true;
             
             document.querySelectorAll('.term-slot').forEach(slot => {
                const expectedTerm = slot.dataset.correctTerm;
                const placedItem = slot.querySelector('.term-item');
                
                if (placedItem) {
                    const placedTerm = placedItem.dataset.term;
                    if (placedTerm === expectedTerm) { 
                        slot.classList.add('correct'); 
                    } else { 
                        slot.classList.add('incorrect'); 
                        allMatchesCorrect = false; 
                    }
                } else { 
                    allSlotsFilled = false; 
                    allMatchesCorrect = false; 
                }
             });
             
             // Highlight unplaced items in pool
             Array.from(termPool.children).forEach(item => {
                 if (item.classList.contains('term-item')) { 
                     item.classList.add('unplaced'); 
                     allMatchesCorrect = false; 
                 }
             });
             
             if (allSlotsFilled && allMatchesCorrect) { 
                 // Optional: Add a victory animation or confetti here
                 console.log("Victory!"); 
             }
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
             document.querySelectorAll('.term-item').forEach(item => item.style.border = '');
             document.querySelectorAll('.term-slot').forEach(slot => slot.classList.remove('correct', 'incorrect'));
            initializeGame();
        });

        // --- Initial Game Setup ---
        initializeGame();

        function cleanUpDragListeners() {
            document.removeEventListener('pointermove', handlePointerMoveTerm);
            document.removeEventListener('pointerup', handlePointerUpTerm);
            document.removeEventListener('pointercancel', handlePointerUpTerm);
            document.body.style.userSelect = '';
        }

    });
    </script>
</body>
</html>
