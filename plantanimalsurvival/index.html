<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Plants vs. Animals: Sort & Learn</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --header-bg: #107c71; /* Teal-700 */
            --text-light: #ffffff;
            --text-dark: #374151; /* Gray-700 */
            --bg-page: #f0f7f6; /* Lighter teal/gray */
            --bg-panel: #ffffff;
            --plant-zone-bg: #f0fdf4; /* Green-50 */
            --plant-zone-border: #a7f3d0; /* Green-200 */
            --plant-zone-label-bg: #6ee7b7; /* Green-300 */
            --animal-zone-bg: #eff6ff; /* Blue-50 */
            --animal-zone-border: #bfdbfe; /* Blue-200 */
            --animal-zone-label-bg: #93c5fd; /* Blue-300 */
            --both-zone-bg: #fefce8; /* Yellow-50 */
            --both-zone-border: #fef08a; /* Yellow-200 */
            --both-zone-label-bg: #fde047; /* Yellow-400 */
            --pool-bg: #f3f4f6; /* Gray-100 */
            --pool-border: #e5e7eb; /* Gray-200 */
            --correct-border: #34d399; /* Emerald-400 */
            --incorrect-border: #f87171; /* Red-400 */
            --unplaced-border: #fbbf24; /* Amber-400 */
        }

        body {
            font-family: 'Nunito', sans-serif;
            background-color: var(--bg-page);
            color: var(--text-dark);
            overscroll-behavior: none; /* Prevent pull-to-refresh */
        }

        .header-bar {
            background-color: var(--header-bg);
            color: var(--text-light);
            padding: 0.5rem 0; /* Tailwind: py-2 */
            width: 100%;
            text-align: center;
            margin-bottom: 0.75rem; /* Tailwind: mb-3 */
            border-radius: 0.375rem; /* Tailwind: rounded-md */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .header-bar h1 {
            font-size: 1.5rem; /* Tailwind: text-2xl */
            margin:0;
            font-weight: 700; /* Tailwind: font-bold */
        }
        p.instructions {
            color: var(--text-dark);
            margin: 0 auto 0.75rem; /* Tailwind: mx-auto mb-3 */
            text-align: center;
            font-size: 0.875rem; /* Tailwind: text-sm */
            max-width: 100%;
        }

        .game-container {
            background-color: var(--bg-panel);
            width: 100%;
            max-width: 500px; /* Slightly wider for 3 columns */
            padding: 0.75rem; /* Tailwind: p-3 */
            border-radius: 0.5rem; /* Tailwind: rounded-lg */
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            position: relative; /* For absolute positioning of dragged items */
        }

        #items-pool-container {
            padding: 0.5rem; /* Tailwind: p-2 */
            background-color: var(--pool-bg);
            border: 1px solid var(--pool-border);
            border-radius: 0.375rem; /* Tailwind: rounded-md */
            text-align: center;
            margin-bottom: 0.75rem; /* Tailwind: mb-3 */
        }
        #items-pool-container h2 {
            margin-top: 0;
            margin-bottom: 0.5rem; /* Tailwind: mb-2 */
            font-size: 1rem; /* Tailwind: text-base */
            color: var(--text-dark);
            font-weight: 600; /* Tailwind: font-semibold */
        }
        #items-pool {
            display: flex;
            flex-wrap: wrap;
            gap: 0.375rem; /* Tailwind: gap-1.5 */
            justify-content: center;
            min-height: 60px; /* Adjusted */
        }

        .item {
            width: 70px; /* Default width for items in the pool */
            height: 75px; /* Default height */
            background-color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 0.25rem; /* Tailwind: rounded-sm */
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            cursor: grab;
            touch-action: none; /* Essential for pointer events */
            user-select: none;
            position: relative;
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, opacity 0.2s ease-out;
            border: 2px solid transparent;
            padding: 0.25rem; /* Tailwind: p-1 */
            text-align: center;
        }
        .item .emoji-icon {
            font-size: 1.5rem; /* Tailwind: text-2xl */
            margin-bottom: 0.125rem; /* Tailwind: mb-0.5 */
            pointer-events: none;
            user-select: none;
        }
        .item-label {
            font-size: 0.65rem; /* Slightly smaller */
            color: var(--text-dark);
            pointer-events: none;
            user-select: none;
            line-height: 1.1;
            max-width: 100%;
            overflow-wrap: break-word;
        }

        /* Class for items being dragged with pointer events */
        .item.dragging {
            opacity: 0.75;
            cursor: grabbing;
            position: absolute; /* Relative to game-container */
            z-index: 1000;
            box-shadow: 0 6px 12px rgba(0,0,0,0.25);
            transform: scale(1.1);
            transform-origin: 0 0; /* Crucial for offset calculation */
            transition: none; /* Immediate feedback during drag */
        }
        /* Class for items being dragged with native mouse drag */
        .item.native-dragging {
            opacity: 0.4;
        }

        .zones-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* Three columns */
            gap: 0.5rem; /* Tailwind: gap-2 */
            margin-bottom: 0.75rem; /* Tailwind: mb-3 */
        }
        .zone-wrapper {
            display: flex;
            flex-direction: column;
            border-radius: 0.375rem; /* Tailwind: rounded-md */
            border: 1px solid transparent; /* Base border */
        }
        .zone-label {
            font-weight: 600; /* Tailwind: font-semibold */
            margin-bottom: 0.25rem; /* Tailwind: mb-1 */
            color: var(--text-dark);
            text-align:center;
            padding: 0.375rem; /* Tailwind: p-1.5 */
            border-radius: 0.25rem 0.25rem 0 0; /* Tailwind: rounded-t-sm */
            font-size: 0.875rem; /* Tailwind: text-sm */
        }
        #plant-label { background-color: var(--plant-zone-label-bg); color: #065f46; /* Green-800 */}
        #animal-label { background-color: var(--animal-zone-label-bg); color: #1e40af; /* Blue-800 */}
        #both-label { background-color: var(--both-zone-label-bg); color: #854d0e; /* Yellow-800 */}

        .drop-zone {
            width:100%;
            min-height:120px; /* Adjusted height */
            border:2px dashed #ccc;
            border-radius:0 0 0.25rem 0.25rem; /* Tailwind: rounded-b-sm */
            border-top: none;
            padding:0.375rem; /* Tailwind: p-1.5 */
            display:flex;
            flex-wrap:wrap;
            gap:0.25rem; /* Tailwind: gap-1 */
            align-content:flex-start;
            justify-content: center;
            transition: background-color .3s, border-style .3s;
        }
        /* Styling for items specifically within a drop zone */
        .drop-zone .item {
            flex-grow: 1;   /* Allow item to grow to fill horizontal space */
            flex-shrink: 1; /* Allow item to shrink if needed */
            flex-basis: 60px; /* Suggest an initial width, allows more items per row. Original is 70px. */
            max-width: 130px; /* Prevent a single item from becoming excessively wide. */
            /* height: 75px; is inherited from .item and remains fixed */
            cursor: default; /* Standard cursor for items in zones */
            /* width: auto; /* Overridden by flex-basis */
        }

        #plant-zone { background-color: var(--plant-zone-bg); border-color: var(--plant-zone-border); }
        #animal-zone { background-color: var(--animal-zone-bg); border-color: var(--animal-zone-border); }
        #both-zone { background-color: var(--both-zone-bg); border-color: var(--both-zone-border); }

        .drop-zone.over {
            border-style: solid;
            filter: brightness(0.95);
        }
        /* .drop-zone .item { cursor: default; }  This is now part of the more specific .drop-zone .item rule */

        .controls {
            text-align:center;
            margin-top: 0.5rem; /* Tailwind: mt-2 */
        }
        .controls button {
            background-color: #2563eb; /* Blue-600 */
            color: var(--text-light);
            border:none;
            padding: 0.5rem 1rem; /* Tailwind: py-2 px-4 */
            border-radius: 0.375rem; /* Tailwind: rounded-md */
            cursor:pointer;
            margin: 0.25rem; /* Tailwind: m-1 */
            font-size:0.875rem; /* Tailwind: text-sm */
            font-weight:600; /* Tailwind: font-semibold */
            font-family:'Nunito',sans-serif;
            transition:background-color .3s, transform 0.1s;
            box-shadow: 0 1px 2px rgba(0,0,0,0.15);
        }
        .controls button:hover { background-color: #1d4ed8; /* Blue-700 */ transform: translateY(-1px); }
        .controls button:active { transform: translateY(0px); background-color: #1e3a8a; /* Blue-800 */ }
        #check-btn { background-color: #16a34a; /* Green-600 */ }
        #check-btn:hover { background-color: #15803d; /* Green-700 */ }
        #check-btn:active { background-color: #166534; /* Green-800 */ }


        #message-area {
            text-align: center; font-size: 0.875rem; /* Tailwind: text-sm */
            font-weight: 600; /* Tailwind: font-semibold */
            margin-top: 0.75rem; /* Tailwind: mt-3 */
            min-height: 1.5em;
            padding: 0.375rem; /* Tailwind: p-1.5 */
            border-radius: 0.375rem; /* Tailwind: rounded-md */
        }
        .message-correct { background-color: #d1fae5; color: #065f46; border: 1px solid #a7f3d0;} /* Green */
        .message-incorrect { background-color: #fee2e2; color: #991b1b; border: 1px solid #fecaca;} /* Red */
        .message-progress { background-color: #fef3c7; color: #92400e; border: 1px solid #fde68a;} /* Amber */

    </style>
</head>
<body class="flex flex-col items-center p-2 sm:p-4">

    <header class="header-bar">
        <h1>Plants vs. Animals Survival</h1>
    </header>
    <p class="instructions">Drag the cards to the correct category: 'Plants', 'Animals', or 'Both'.</p>

    <div class="game-container">
        <div id="items-pool-container">
            <h2>Available Cards</h2>
            <div id="items-pool">
                </div>
        </div>

        <div class="zones-container">
            <div class="zone-wrapper">
                <div id="plant-label" class="zone-label">Plants</div>
                <div id="plant-zone" class="drop-zone" data-category="plant"></div>
            </div>
            <div class="zone-wrapper">
                <div id="animal-label" class="zone-label">Animals</div>
                <div id="animal-zone" class="drop-zone" data-category="animal"></div>
            </div>
            <div class="zone-wrapper">
                <div id="both-label" class="zone-label">Both</div>
                <div id="both-zone" class="drop-zone" data-category="both"></div>
            </div>
        </div>

        <div class="controls">
            <button id="check-btn" type="button">Check Answers</button>
            <button id="reset-btn" type="button">Reset Game</button>
        </div>

        <div id="message-area"></div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const ITEMS_DATA = [
            // Plants
            {key:'makeFood', category:'plant', label:'Make own food', emoji:'â˜€ï¸'},
            {key:'noMovePlant', category:'plant', label:'Canâ€™t usually move', emoji:'ðŸª´'},
            {key:'roots', category:'plant', label:'Have roots', emoji:'ðŸŒ±'},
            {key:'leaves', category:'plant', label:'Have leaves', emoji:'ðŸƒ'},
            // Both
            {key:'needWater', category:'both', label:'Need water', emoji:'ðŸ’§'},
            {key:'needAir', category:'both', label:'Need air', emoji:'ðŸ’¨'},
            {key:'liveEarth', category:'both', label:'Live on Earth', emoji:'ðŸŒ'},
            {key:'canGrow', category:'both', label:'Can grow', emoji:'ðŸŒ¿'},
            {key:'foodChain', category:'both', label:'Part of food chain', emoji:'ðŸ”—'},
            // Animals
            {key:'findFood', category:'animal', label:'Need to find food', emoji:'ðŸŽ'},
            {key:'moveAnimal', category:'animal', label:'Can usually move', emoji:'ðŸƒ'},
            {key:'shelter', category:'animal', label:'Need shelter', emoji:'ðŸ '},
            {key:'walkFlySwim', category:'animal', label:'Walk, fly, or swim', emoji:'ðŸš¶'},
        ];

        const itemsPool = document.getElementById('items-pool');
        const dropZones = document.querySelectorAll('.drop-zone');
        const gameContainer = document.querySelector('.game-container');
        const messageArea = document.getElementById('message-area');

        let pointerDraggedItem = null;
        let offsetX = 0, offsetY = 0;
        let currentOverZone = null;
        let isTouchDragging = false; // Flag to distinguish touch drags for specific handling

        function initializeGame() {
            itemsPool.innerHTML = '';
            dropZones.forEach(zone => {
                zone.innerHTML = '';
                zone.classList.remove('over');
            });
            messageArea.textContent = 'Drag cards to begin!';
            messageArea.className = 'message-progress'; // Initial neutral message

            ITEMS_DATA.sort(() => Math.random() - 0.5).forEach((itemData, idx) => {
                const card = document.createElement('div');
                card.className = 'item';
                card.draggable = true; // For native mouse drag fallback
                card.id = `item-${itemData.key}-${idx}`; // Unique ID
                card.dataset.itemKey = itemData.key;
                card.dataset.category = itemData.category;

                const emojiSpan = document.createElement('span');
                emojiSpan.className = 'emoji-icon';
                emojiSpan.textContent = itemData.emoji;

                const labelSpan = document.createElement('span');
                labelSpan.className = 'item-label';
                labelSpan.textContent = itemData.label;

                card.appendChild(emojiSpan);
                card.appendChild(labelSpan);

                // Pointer events for unified touch and mouse dragging
                card.addEventListener('pointerdown', handlePointerDown);
                // Native drag events (primarily for mouse fallback/desktop)
                card.addEventListener('dragstart', handleDragStartMouse);
                card.addEventListener('dragend', handleDragEndMouse);

                itemsPool.appendChild(card);
            });
            // Reset state variables
            pointerDraggedItem = null; isTouchDragging = false; currentOverZone = null;
        }

        // --- Native Mouse Drag Handlers (Fallback) ---
        function handleDragStartMouse(e) {
            // Prevent native drag if it's a touch event that pointerdown will handle
            if (e.pointerType === 'touch') {
                e.preventDefault();
                return;
            }
            e.dataTransfer.setData('text/plain', e.currentTarget.id);
            e.dataTransfer.effectAllowed = 'move';
            // Add a class to style the original item while dragging (e.g., make it semi-transparent)
            setTimeout(() => { e.target.classList.add('native-dragging'); }, 0);
            isTouchDragging = false; // Ensure this is false for native drag
        }

        function handleDragEndMouse(e) {
            if (e.pointerType === 'touch') return; // Handled by pointerup
            e.target.classList.remove('native-dragging');
            // Clean up any 'over' state on zones if drag ends outside a valid target
            dropZones.forEach(zone => zone.classList.remove('over'));
            isTouchDragging = false; pointerDraggedItem = null; currentOverZone = null;
        }

        dropZones.forEach(zone => {
            zone.addEventListener('dragover', handleDragOverMouse);
            zone.addEventListener('dragleave', handleDragLeaveMouse);
            zone.addEventListener('drop', handleDropMouse);
        });

        function handleDragOverMouse(e) {
            if (isTouchDragging) return; // Let pointermove handle this for touch
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            e.currentTarget.classList.add('over');
        }
        function handleDragLeaveMouse(e) {
            if (isTouchDragging) return;
            e.currentTarget.classList.remove('over');
        }

        function handleDropMouse(e) {
            if (isTouchDragging) return; // Let pointerup handle this for touch
            e.preventDefault();
            const id = e.dataTransfer.getData('text/plain');
            const droppedElement = document.getElementById(id);
            const targetZone = e.currentTarget.classList.contains('drop-zone') ? e.currentTarget : (e.currentTarget.id === 'items-pool' ? e.currentTarget : null);


            if (droppedElement && targetZone) {
                droppedElement.classList.remove('native-dragging'); // Clean up style
                targetZone.appendChild(droppedElement);
                messageArea.textContent = `Dropped "${droppedElement.querySelector('.item-label').textContent}"`;
                messageArea.className = 'message-progress';
            }
            if(targetZone) targetZone.classList.remove('over');
            currentOverZone = null; // Reset current over zone
        }

        // --- Pointer Event Handlers (Primary for Touch, also works for Mouse) ---
        function handlePointerDown(e) {
            // Allow only primary button (e.g., left mouse, single touch)
            // and if no item is already being dragged by pointer events
            if (e.button !== 0 || pointerDraggedItem) return;

            pointerDraggedItem = e.currentTarget;
            isTouchDragging = e.pointerType === 'touch'; // True if touch, false if mouse/pen using pointer events

            // Clear any previous feedback borders on the item
            pointerDraggedItem.style.borderColor = 'transparent';
            messageArea.textContent = ''; messageArea.className = '';

            // Capture the pointer to receive further events like pointermove and pointerup
            try {
                pointerDraggedItem.setPointerCapture(e.pointerId);
            } catch (err) {
                console.warn("Pointer capture failed. This might happen if the element is removed or display is set to none.", err);
                pointerDraggedItem = null; // Reset if capture fails
                return;
            }


            // Calculate offset of the pointer from the top-left of the item
            const rect = pointerDraggedItem.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;

            // Apply dragging style (absolute positioning, scaling etc.)
            pointerDraggedItem.classList.add('dragging');

            // Add global listeners for move and up/cancel
            document.addEventListener('pointermove', handlePointerMove);
            document.addEventListener('pointerup', handlePointerUp);
            document.addEventListener('pointercancel', handlePointerUp); // Treat cancel like up

            document.body.style.userSelect = 'none'; // Prevent text selection during drag
        }

        function handlePointerMove(e) {
            if (!pointerDraggedItem || !pointerDraggedItem.hasPointerCapture(e.pointerId)) return;

            e.preventDefault(); // Prevent default actions like scrolling, especially on touch

            // Calculate new position for the dragged item (relative to gameContainer)
            const gameRect = gameContainer.getBoundingClientRect();
            const scaleFactor = 1.1; // Must match CSS transform: scale(1.1)

            // Adjust for the item's transform-origin: 0 0 and scaling
            let newX = (e.clientX - gameRect.left) - (offsetX * scaleFactor);
            let newY = (e.clientY - gameRect.top) - (offsetY * scaleFactor);

            pointerDraggedItem.style.left = `${newX}px`;
            pointerDraggedItem.style.top = `${newY}px`;

            // Drop zone highlighting logic
            // Temporarily hide the dragged item to correctly detect element underneath
            const originalVisibility = pointerDraggedItem.style.visibility;
            pointerDraggedItem.style.visibility = 'hidden';
            let elementUnderPointer = document.elementFromPoint(e.clientX, e.clientY);
            pointerDraggedItem.style.visibility = originalVisibility; // Restore visibility

            // Check if elementUnderPointer is items-pool itself, or a drop-zone
            let dropTarget = null;
            if (elementUnderPointer) {
                if (elementUnderPointer.id === 'items-pool' || elementUnderPointer.closest('#items-pool')) {
                    dropTarget = itemsPool; // Target the main itemsPool div
                } else {
                    dropTarget = elementUnderPointer.closest('.drop-zone');
                }
            }


            // Update 'over' class on zones
            if (currentOverZone && currentOverZone !== dropTarget) {
                currentOverZone.classList.remove('over');
            }
            if (dropTarget && dropTarget !== currentOverZone) {
                dropTarget.classList.add('over');
                currentOverZone = dropTarget;
            } else if (!dropTarget) {
                 if(currentOverZone) currentOverZone.classList.remove('over');
                 currentOverZone = null;
            }
        }

        function handlePointerUp(e) {
            if (!pointerDraggedItem || !pointerDraggedItem.hasPointerCapture(e.pointerId)) {
                 // Clean up global listeners if this somehow gets called without a valid dragged item
                document.removeEventListener('pointermove', handlePointerMove);
                document.removeEventListener('pointerup', handlePointerUp);
                document.removeEventListener('pointercancel', handlePointerUp);
                document.body.style.userSelect = '';
                return;
            }

            document.removeEventListener('pointermove', handlePointerMove);
            document.removeEventListener('pointerup', handlePointerUp);
            document.removeEventListener('pointercancel', handlePointerUp);
            document.body.style.userSelect = '';

            pointerDraggedItem.classList.remove('dragging'); // Remove absolute positioning and scaling
            // Reset inline styles used for positioning
            pointerDraggedItem.style.left = '';
            pointerDraggedItem.style.top = '';
            pointerDraggedItem.style.visibility = '';


            if (currentOverZone) { // currentOverZone can be a .drop-zone or itemsPool
                currentOverZone.appendChild(pointerDraggedItem); 
                currentOverZone.classList.remove('over');
                 messageArea.textContent = `Placed "${pointerDraggedItem.querySelector('.item-label').textContent}"`;
                 messageArea.className = 'message-progress';
            } else {
                // If not over a valid zone (e.g. dropped in empty space), return to the main pool (itemsPool)
                itemsPool.appendChild(pointerDraggedItem);
                 messageArea.textContent = `Returned "${pointerDraggedItem.querySelector('.item-label').textContent}" to pool.`;
                 messageArea.className = 'message-progress';
            }

            try {
                pointerDraggedItem.releasePointerCapture(e.pointerId);
            } catch (err) {
                // console.warn("Failed to release pointer capture.", err);
            }

            // Reset state
            pointerDraggedItem = null;
            isTouchDragging = false;
            currentOverZone = null;
            offsetX = 0;
            offsetY = 0;
        }

        // --- Game Logic Buttons ---
        document.getElementById('check-btn').addEventListener('click', () => {
            let allCorrect = true;
            let itemsInWrongZone = false;
            let itemsStillInPool = false;

            // Clear previous borders and messages
            document.querySelectorAll('.item').forEach(item => item.style.borderColor = 'transparent');
            messageArea.textContent = ''; messageArea.className = '';

            dropZones.forEach(zone => {
                const zoneCategory = zone.dataset.category;
                Array.from(zone.children).forEach(item => {
                    if (item.classList.contains('item')) {
                        const itemCategory = item.dataset.category;
                        const isCorrect = itemCategory === zoneCategory;
                        item.style.borderColor = isCorrect ? 'var(--correct-border)' : 'var(--incorrect-border)';
                        if (!isCorrect) {
                            allCorrect = false;
                            itemsInWrongZone = true;
                        }
                    }
                });
            });

            Array.from(itemsPool.children).forEach(item => {
                if (item.classList.contains('item')) {
                    item.style.borderColor = 'var(--unplaced-border)';
                    allCorrect = false;
                    itemsStillInPool = true;
                }
            });

            if (allCorrect && !itemsStillInPool) {
                messageArea.textContent = "Awesome! All items are sorted correctly! ðŸŽ‰";
                messageArea.className = 'message-correct';
            } else if (itemsStillInPool) {
                messageArea.textContent = "Keep going! Some items are still in the pool.";
                messageArea.className = 'message-progress';
            } else if (itemsInWrongZone) {
                messageArea.textContent = "Almost there! Check items with red borders.";
                messageArea.className = 'message-incorrect';
            } else { // Should not be reached if logic is correct, but as a fallback
                messageArea.textContent = "Double check your sorting!";
                messageArea.className = 'message-progress';
            }
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            initializeGame();
        });

        // Initialize the game when the DOM is fully loaded
        initializeGame();
    });
    </script>
</body>
</html>
