<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sorting Game - Transparent vs. Opaque</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    /* ----------  CORE LAYOUT  ---------- */
    :root {
      /* Slate/Green color palette */
      --bg: #64748b; /* Slate background */
      --panel: #F4E4C6; /* Kept light beige panel */
      --btn: #22c55e; /* Green button */
      --btn-hover: #16a34a; /* Darker green hover */
    }
    *{box-sizing:border-box;}
    body{
      margin:0; font-family:'Poppins',sans-serif; background:var(--bg);
      display:flex; flex-direction:column; align-items:center; padding:20px;
      overscroll-behavior: none;
    }
    h1{font-size:2.5rem;color:#fff;margin:5px 0;}
    p{color:#fff;margin:0 0 20px;}

    .game-container{
      background:var(--panel); width:100%; max-width:800px; padding:20px; border-radius:10px;
      position: relative;
    }

    /* ----------  DRAG ITEMS  ---------- */
    #items{display:flex;flex-wrap:wrap;gap:15px;justify-content:center;margin-bottom:20px; min-height: 100px; }
    .item{
      width:80px;height:80px;background:#fff;display:flex;align-items:center;justify-content:center;
      border-radius:8px;box-shadow:0 2px 5px rgba(0,0,0,0.1);cursor:grab;
      touch-action: none;
      user-select: none;
      position: relative;
      transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, opacity 0.2s ease-out;
    }
    .item img {
      pointer-events: none;
      max-width: 50%;
      max-height: 50%;
      user-select: none;
    }
    .item.dragging { opacity: 0.7; cursor: grabbing; position: absolute; z-index: 1000; box-shadow: 0 10px 20px rgba(0,0,0,0.2); transform: scale(1.1); transition: none; }
    .item.native-dragging { opacity: 0.3; }


    /* ----------  DROP ZONES  ---------- */
    .zones{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:20px;}
    .zone-label{font-weight:bold;margin-bottom:5px;color:#333;}
    .drop-zone{ width:100%;min-height:150px;background:#fff;border:2px dashed #ccc;border-radius:8px; padding:10px;display:flex;flex-wrap:wrap;gap:10px;transition:background .3s, border-style .3s; }
    .drop-zone.over{background:#e0e0e0; border-style: solid;}

    /* ----------  CONTROLS  ---------- */
    .controls{text-align:center;}
    .controls button{ background:var(--btn);color:#fff;border:none;padding:10px 20px;border-radius:10px;cursor:pointer; margin:10px 5px;font-size:1.2rem;font-family:'Poppins',sans-serif;transition:background .3s; }
    .controls button:hover{background:var(--btn-hover);}
  </style>
</head>
<body>
  <h1>Transparent vs. Opaque</h1>
  <p>Drag objects to show if light passes through (Transparent) or is blocked (Opaque)</p>

  <div class="game-container">
    <div id="items">
        </div>

    <div class="zones">
      <div class="zone">
        <div class="zone-label">Light Passes Through (Transparent)</div>
        <div id="transparent" class="drop-zone" aria-label="Transparent objects drop zone"></div>
      </div>
      <div class="zone">
        <div class="zone-label">Light Blocked (Opaque)</div>
        <div id="opaque" class="drop-zone" aria-label="Opaque objects drop zone"></div>
      </div>
    </div>

    <div class="controls">
      <button id="check-btn" type="button">Check Answers</button>
      <button id="reset-btn" type="button">Reset</button>
    </div>
  </div>

  <script>
  /**
   * Sorting Game - Transparent vs Opaque (v2 - added ice, replaced bottle with stone)
   */
  document.addEventListener('DOMContentLoaded', () => {
    const om = code => `https://cdn.jsdelivr.net/npm/openmoji@14.0.0/color/svg/${code}.svg`;

    // --- UPDATED ICONS and ITEMS ---
    const ICONS = {
      // Transparent
      window:    `<img src="${om('1FA9F')}" alt="Window">`,
      glass:     `<img src="${om('1F95B')}" alt="Glass of Milk">`, // Represents glass material
      eyeglasses:`<img src="${om('1F453')}" alt="Eyeglasses">`,
      magnifier: `<img src="${om('1F50D')}" alt="Magnifying Glass">`,
      ice:       `<img src="${om('1F9CA')}" alt="Ice Cube">`,    // Added Ice
      // Opaque
      door:      `<img src="${om('1F6AA')}" alt="Door">`,
      brick:     `<img src="${om('1F9F1')}" alt="Brick">`,
      apple:     `<img src="${om('1F34E')}" alt="Apple">`,
      book:      `<img src="${om('1F4D6')}" alt="Book">`,
      mirror:    `<img src="${om('1FA9E')}" alt="Mirror">`,
      stone:     `<img src="${om('1FAA8')}" alt="Stone">`        // Added Stone
     };

    const ITEMS = [
      // Transparent (5 items) - Removed bottle, Added ice
      {key:'window',    category:'transparent'},
      {key:'glass',     category:'transparent'},
      {key:'eyeglasses',category:'transparent'},
      {key:'magnifier', category:'transparent'},
      {key:'ice',       category:'transparent'},
      // Opaque (6 items) - Added stone
      {key:'door',      category:'opaque'},
      {key:'brick',     category:'opaque'},
      {key:'apple',     category:'opaque'},
      {key:'book',      category:'opaque'},
      {key:'mirror',    category:'opaque'},
      {key:'stone',     category:'opaque'}
     ];
    // --- End of UPDATED ICONS and ITEMS ---

    const itemsContainer = document.getElementById('items');
    const dropZones = document.querySelectorAll('.drop-zone');
    const gameContainer = document.querySelector('.game-container');

    // State variables (unchanged)
    let pointerDraggedItem = null;
    let offsetX = 0;
    let offsetY = 0;
    let currentOverZone = null;
    let isTouchDragging = false;

    // Initialization Function (unchanged logic, uses new ITEMS)
    function initializeGame() {
        itemsContainer.innerHTML = '';
        dropZones.forEach(zone => { zone.innerHTML = ''; zone.classList.remove('over'); });
        ITEMS.sort(() => Math.random() - 0.5).forEach((item, idx) => {
            const card = document.createElement('div');
            card.className = 'item';
            card.draggable = true;
            card.id = `item-${idx}`;
            card.dataset.category = item.category; // Assigns 'transparent' or 'opaque'
            card.innerHTML = ICONS[item.key];
            card.addEventListener('dragstart', handleDragStartMouse);
            card.addEventListener('dragend', handleDragEndMouse);
            card.addEventListener('pointerdown', handlePointerDown);
            itemsContainer.appendChild(card);
        });
        pointerDraggedItem = null;
        isTouchDragging = false;
        currentOverZone = null;
    }

    // --- Event Handlers (Mouse D&D, Pointer Events) ---
    // These functions remain IDENTICAL to the previous versions.
    // --- Standard Mouse D&D Handlers ---
    function handleDragStartMouse(e) { if (e.pointerType !== 'touch') { e.dataTransfer.setData('text/plain', e.currentTarget.id); e.dataTransfer.effectAllowed = 'move'; setTimeout(() => { e.target.classList.add('native-dragging'); }, 0); isTouchDragging = false; } else { e.preventDefault(); } }
    function handleDragEndMouse(e) { if (e.pointerType !== 'touch') { e.target.classList.remove('native-dragging'); dropZones.forEach(zone => zone.classList.remove('over')); } isTouchDragging = false; pointerDraggedItem = null; currentOverZone = null; document.body.style.userSelect = ''; }
    dropZones.forEach(zone => { zone.addEventListener('dragover', handleDragOverMouse); zone.addEventListener('dragleave', handleDragLeaveMouse); zone.addEventListener('drop', handleDropMouse); });
    function handleDragOverMouse(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; }
    function handleDragLeaveMouse(e) { /* Rely on pointermove */ }
    function handleDropMouse(e) { e.preventDefault(); if (e.pointerType !== 'touch') { const id = e.dataTransfer.getData('text/plain'); const droppedElement = document.getElementById(id); if (droppedElement) { droppedElement.classList.remove('native-dragging'); } if (droppedElement && !e.currentTarget.contains(droppedElement)) { e.currentTarget.appendChild(droppedElement); } e.currentTarget.classList.remove('over'); currentOverZone = null; } }
    // --- Pointer Event Handlers ---
    function handlePointerDown(e) { if (e.button !== 0 || pointerDraggedItem) return; pointerDraggedItem = e.currentTarget; isTouchDragging = e.pointerType === 'touch'; if (isTouchDragging) { e.preventDefault(); pointerDraggedItem.setPointerCapture(e.pointerId); const rect = pointerDraggedItem.getBoundingClientRect(); offsetX = e.clientX - rect.left; offsetY = e.clientY - rect.top; pointerDraggedItem.style.border = ''; pointerDraggedItem.classList.add('dragging'); } else { try { pointerDraggedItem.setPointerCapture(e.pointerId); } catch (err) {} } document.addEventListener('pointermove', handlePointerMove); document.addEventListener('pointerup', handlePointerUp); document.addEventListener('pointercancel', handlePointerUp); document.body.style.userSelect = 'none'; }
    function handlePointerMove(e) { if (!pointerDraggedItem || !pointerDraggedItem.hasPointerCapture(e.pointerId)) return; if (isTouchDragging) { e.preventDefault(); const gameRect = gameContainer.getBoundingClientRect(); let newX = e.clientX - gameRect.left - offsetX; let newY = e.clientY - gameRect.top - offsetY; pointerDraggedItem.style.left = `${newX}px`; pointerDraggedItem.style.top = `${newY}px`; } let elementUnderPointer = null; const originalVisibility = isTouchDragging ? pointerDraggedItem.style.visibility : ''; if (isTouchDragging) { pointerDraggedItem.style.visibility = 'hidden'; } elementUnderPointer = document.elementFromPoint(e.clientX, e.clientY); if (isTouchDragging) { pointerDraggedItem.style.visibility = originalVisibility; } let dropTarget = elementUnderPointer ? elementUnderPointer.closest('.drop-zone') : null; if (currentOverZone && currentOverZone !== dropTarget) { currentOverZone.classList.remove('over'); } if (dropTarget) { dropTarget.classList.add('over'); currentOverZone = dropTarget; } else { currentOverZone = null; } }
    function handlePointerUp(e) { if (!pointerDraggedItem || !pointerDraggedItem.hasPointerCapture(e.pointerId)) { document.removeEventListener('pointermove', handlePointerMove); document.removeEventListener('pointerup', handlePointerUp); document.removeEventListener('pointercancel', handlePointerUp); document.body.style.userSelect = ''; return; } document.removeEventListener('pointermove', handlePointerMove); document.removeEventListener('pointerup', handlePointerUp); document.removeEventListener('pointercancel', handlePointerUp); document.body.style.userSelect = ''; if (isTouchDragging) { pointerDraggedItem.classList.remove('dragging'); pointerDraggedItem.style.left = ''; pointerDraggedItem.style.top = ''; pointerDraggedItem.style.visibility = ''; if (currentOverZone) { if (!currentOverZone.contains(pointerDraggedItem)) { currentOverZone.appendChild(pointerDraggedItem); } currentOverZone.classList.remove('over'); } else { itemsContainer.appendChild(pointerDraggedItem); } } else { pointerDraggedItem.classList.remove('native-dragging'); if (currentOverZone) { currentOverZone.classList.remove('over'); } } try { pointerDraggedItem.releasePointerCapture(e.pointerId); } catch(err) {} pointerDraggedItem = null; isTouchDragging = false; currentOverZone = null; offsetX = 0; offsetY = 0; }


    // --- Control Button Listeners ---
    // Check logic uses the item's dataset.category ('transparent' or 'opaque')
    // and compares it to the drop zone's ID ('transparent' or 'opaque')
    document.getElementById('check-btn').addEventListener('click', () => {
        let allCorrect = true;
        const zoneIds = ['transparent', 'opaque']; // Match drop zone IDs
        zoneIds.forEach(zoneId => {
            const zone = document.getElementById(zoneId);
            Array.from(zone.children).forEach(item => {
                if (item.classList.contains('item')) {
                    const isCorrect = item.dataset.category === zoneId;
                    item.style.border = isCorrect ? '3px solid #22c55e' : '3px solid #ef4444';
                    if (!isCorrect) allCorrect = false;
                }
            });
        });
       Array.from(itemsContainer.children).forEach(item => {
           if (item.classList.contains('item')) {
               item.style.border = '3px solid #f97316'; // Mark as unplaced
               allCorrect = false;
           }
       });
       if(allCorrect && itemsContainer.children.length === 0) {
         console.log("All items placed correctly!");
       }
    });

    // Reset button calls initializeGame (unchanged)
    document.getElementById('reset-btn').addEventListener('click', () => {
        initializeGame();
    });

    // --- Initial Game Setup ---
    initializeGame();

  });
  </script>
</body>
</html>
