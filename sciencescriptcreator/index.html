<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vids Script Creator - Particle Theory</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f3f4f6; /* Tailwind gray-100 */
            color: #1f2937; /* Tailwind gray-800 */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px; /* Overall page padding */
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            padding: 20px 15px; /* Reduced side padding from 20px to 15px */
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 1200px; 
        }
        h1 {
            color: #1e40af; /* Tailwind blue-700 */
            margin-bottom: 10px;
            font-size: 1.8rem;
            text-align: center;
            font-weight: 700;
        }
        h2 {
            color: #1d4ed8; /* Tailwind blue-600 */
            margin-bottom: 15px;
            font-size: 1.1rem;
            text-align: center;
            font-weight: 500;
        }
        .main-layout {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        @media (min-width: 768px) { /* Apply row layout for medium screens and up */
            .main-layout {
                flex-direction: row;
            }
        }
        .source-text-column {
            flex: 1.8; /* Was 1. Increased to take more space */
            min-width: 300px; /* Ensures a minimum usable width */
            padding-right: 8px; /* Reduced from 10px */
            border-right: 1px solid #e5e7eb; 
        }
        .scenes-column {
            flex: 1; /* Stays as 1, will be proportionally smaller */
            min-width: 280px; /* Ensures a minimum usable width, can be slightly less */
            padding-left: 8px;  /* Reduced from 10px */
        }
        .source-text-content p {
            margin-bottom: 1em;
            line-height: 1.8; 
        }
        .text-chunk {
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
            padding: 2px 4px;
            border-radius: 4px;
            margin: 0 1px;
            display: inline; 
        }
        .text-chunk:hover {
            background-color: #dbeafe; /* Tailwind blue-100 */
            color: #1e40af; /* Tailwind blue-700 */
        }
        .text-chunk.clicked-once {
            background-color: #bfdbfe; /* Tailwind blue-200 */
            font-weight: 500;
        }
         .text-chunk.clicked-twice {
            background-color: #93c5fd; /* Tailwind blue-300 */
            font-weight: 600;
        }
        .scene-box {
            margin-bottom: 15px;
            border: 1px solid #d1d5db; /* Tailwind gray-300 */
            border-radius: 8px;
            padding: 5px; 
            background-color: #f9fafb; /* Tailwind gray-50 */
            display: flex; 
            flex-direction: column; 
        }
        .scene-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #e5e7eb; /* Tailwind gray-200 */
            border-top-left-radius: 7px;
            border-top-right-radius: 7px;
            padding: 5px 8px;
        }
        .scene-header-buttons { 
            display: flex;
            align-items: center;
        }
        .scene-box label {
            font-weight: 600;
            color: #374151; /* Tailwind gray-700 */
            cursor: pointer; 
            flex-grow: 1; 
        }
        .scene-box textarea {
            width: 100%;
            min-height: 100px; 
            border: none;
            padding: 8px;
            border-radius: 0 0 7px 7px; 
            font-size: 0.9rem;
            resize: vertical;
            background-color: #ffffff;
            border-top: 1px solid #d1d5db; 
        }
        .scene-box.active-scene .scene-header { 
            background-color: #3b82f6; /* Tailwind blue-500 */
        }
        .scene-box.active-scene .scene-header label { 
            color: white;
        }
        .scene-action-btn { 
            color: white;
            border: none;
            padding: 3px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            margin-left: 5px; 
            line-height: 1;
        }
        .clear-specific-scene-btn {
            background-color: #6b7280; /* Tailwind gray-500 */
        }
        .clear-specific-scene-btn:hover {
            background-color: #4b5563; /* Tailwind gray-600 */
        }
        .copy-specific-scene-btn { 
            background-color: #2563eb; /* Tailwind blue-600 */
        }
        .copy-specific-scene-btn:hover {
            background-color: #1d4ed8; /* Tailwind blue-700 */
        }
        .action-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .action-buttons button {
            background-color: #2563eb; /* Tailwind blue-600 */
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: background-color 0.3s ease;
        }
        .action-buttons button:hover {
            background-color: #1d4ed8; /* Tailwind blue-700 */
        }
        #feedbackArea {
            margin-top: 15px;
            text-align: center;
            font-weight: 500;
            color: #16a34a; /* Tailwind green-600 */
            min-height: 24px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Vids Script Creator</h1>
        <h2>Particle Theory of Matter</h2>

        <div class="main-layout">
            <div class="source-text-column">
                <h3>Source Text (Click to add to active scene)</h3>
                <div id="sourceTextContent" class="source-text-content">
                    </div>
            </div>

            <div class="scenes-column">
                <h3>Script Scenes</h3>
                <div id="scenesContainer">
                    </div>
                <div class="flex justify-center mt-2">
                     <button id="addSceneBtn" class="py-2 px-4 bg-green-500 hover:bg-green-600 text-white rounded-lg text-sm font-medium">Add New Scene</button>
                </div>
            </div>
        </div>

        <div class="action-buttons">
            <button id="saveScriptBtn">Save Full Script</button>
            <button id="copyScriptBtn">Copy Full Script</button>
            <button id="loadScriptBtn">Load Last Saved Script</button>
        </div>
        <div id="feedbackArea" role="status"></div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, serverTimestamp, collection, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'vids-script-creator-default';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
            apiKey: "YOUR_FALLBACK_API_KEY", 
            authDomain: "YOUR_FALLBACK_AUTH_DOMAIN",
            projectId: "YOUR_FALLBACK_PROJECT_ID",
            storageBucket: "YOUR_FALLBACK_STORAGE_BUCKET",
            messagingSenderId: "YOUR_FALLBACK_MESSAGING_SENDER_ID",
            appId: "YOUR_FALLBACK_APP_ID"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        // setLogLevel('debug'); 

        let userId = null; 

        const particleTheoryText = [
            ["What's the Matter?", "Tiny Particles Explain it All! ðŸ§ª", "How can states of matter and other physical properties be explained using the particle model of matter?"],
            ["Everything you see and touch is matter,", "and all matter is made of super tiny particles!", "These amazing little particles are always moving,", "they have spaces between them,", "and they attract each other,", "like little friends sticking together."],
            ["How these particles act makes matter a solid,", "a liquid,", "or a gas.", "In solids,", "like a hard rock ðŸ§Š or your table,", "particles are packed very close together.", "They just vibrate or wiggle in one spot", "because strong attractions hold them tight!", "The spaces between them are super tiny.", "Think of kids sitting neatly in class,", "just wiggling in their seats!"],
            ["In liquids,", "like water ðŸ’§ or your juice,", "particles are also close,", "but they can slide past each other.", "That's why liquids can flow and take the shape of their container!", "The attraction between them is medium,", "and they have small spaces.", "Imagine kids walking around a room,", "able to move but still staying together."],
            ["In gases,", "like the air you breathe ðŸŽˆ or steam from hot water,", "particles are very far apart.", "They zoom quickly in all directions,", "spreading out everywhere!", "The attraction between them is very weak,", "and there are big spaces between them.", "Picture kids running all over a giant playground,", "far apart and zipping everywhere!"],
            ["We can describe matter using its physical properties.", "Mass tells us how much \"stuff\" is in an object.", "We measure it in grams (g) or kilograms (kg)", "using a balance scale.", "Volume tells us how much space something takes up.", "For liquids, we measure volume in millilitres (mL) or litres (L)", "using things like measuring cups."],
            ["Density is about how \"packed\" the matter is.", "If something is denser than a liquid,", "it will sink.", "If it's less dense,", "it will float!", "Solids are usually the densest", "because their particles are packed tight.", "Gases are the least dense", "because their particles are so spread out.", "Liquids are in the middle."],
            ["Compressibility means if something can be squished into a smaller space.", "Gases can be compressed easily", "because there are big spaces between their particles â€“", "you can push them closer!", "Think of pumping air into a ball.", "Liquids and solids can't really be compressed much", "because their particles are already close together."],
            ["So go ahead,", "be a super scientist! ðŸ§‘â€ðŸ”¬", "Think about these tiny particles", "when you look at solids, liquids, and gases.", "You can even try to draw how the particles look!", "Just always remember to be safe when you're exploring."]
        ];

        const sourceTextContentDiv = document.getElementById('sourceTextContent');
        const scenesContainer = document.getElementById('scenesContainer');
        const addSceneBtn = document.getElementById('addSceneBtn');
        const saveScriptBtn = document.getElementById('saveScriptBtn');
        const copyScriptBtn = document.getElementById('copyScriptBtn'); 
        const loadScriptBtn = document.getElementById('loadScriptBtn');
        const feedbackArea = document.getElementById('feedbackArea');

        let activeSceneIndex = 0;
        let sceneData = []; 

        function renderSourceText() {
            sourceTextContentDiv.innerHTML = '';
            particleTheoryText.forEach(paragraph => {
                const pElement = document.createElement('p');
                paragraph.forEach(chunkText => {
                    const span = document.createElement('span');
                    span.textContent = chunkText + " "; 
                    span.classList.add('text-chunk');
                    span.addEventListener('click', () => handleChunkClick(chunkText, span));
                    pElement.appendChild(span);
                });
                sourceTextContentDiv.appendChild(pElement);
            });
        }
        
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }

        function renderScene(sceneObject, index) {
            const sceneBox = document.createElement('div');
            sceneBox.classList.add('scene-box');
            sceneBox.dataset.sceneId = sceneObject.id; 
            sceneBox.dataset.sceneIndex = index; 

            const sceneHeader = document.createElement('div');
            sceneHeader.classList.add('scene-header');

            const label = document.createElement('label');
            label.textContent = `Scene ${index + 1}`;
            label.addEventListener('click', () => setActiveScene(index));
            
            const headerButtons = document.createElement('div'); 
            headerButtons.classList.add('scene-header-buttons');

            const copyBtn = document.createElement('button'); 
            copyBtn.textContent = 'Copy';
            copyBtn.classList.add('scene-action-btn', 'copy-specific-scene-btn');
            copyBtn.title = `Copy text from Scene ${index + 1}`;
            copyBtn.addEventListener('click', (e) => {
                e.stopPropagation(); 
                copySpecificSceneText(sceneObject.id, index);
            });

            const clearBtn = document.createElement('button');
            clearBtn.textContent = 'Clear';
            clearBtn.classList.add('scene-action-btn', 'clear-specific-scene-btn');
            clearBtn.title = `Clear text from Scene ${index + 1}`;
            clearBtn.addEventListener('click', (e) => {
                e.stopPropagation(); 
                clearSpecificSceneText(sceneObject.id, index);
            });
            
            headerButtons.appendChild(copyBtn); 
            headerButtons.appendChild(clearBtn);

            sceneHeader.appendChild(label);
            sceneHeader.appendChild(headerButtons); 
            
            const textarea = document.createElement('textarea');
            textarea.value = sceneObject.content;
            textarea.setAttribute('aria-label', `Content for Scene ${index + 1}`);
            textarea.addEventListener('input', (e) => {
                const sceneId = sceneBox.dataset.sceneId;
                const sceneIndexInArray = sceneData.findIndex(s => s.id === sceneId);
                if (sceneIndexInArray !== -1) {
                    sceneData[sceneIndexInArray].content = e.target.value;
                }
            });

            sceneBox.appendChild(sceneHeader);
            sceneBox.appendChild(textarea);
            scenesContainer.appendChild(sceneBox);
            
            if (index === activeSceneIndex) {
                sceneBox.classList.add('active-scene');
            }
        }

        function renderAllScenes() {
            scenesContainer.innerHTML = '';
            sceneData.forEach((sceneObj, index) => {
                renderScene(sceneObj, index);
            });
            setActiveScene(activeSceneIndex);
        }
        
        function addNewScene() {
            const newSceneId = generateUniqueId();
            sceneData.push({ id: newSceneId, content: "" });
            renderAllScenes(); 
            setActiveScene(sceneData.length - 1); 
        }


        function setActiveScene(index) {
            if (index < 0 || index >= sceneData.length) {
                 if (sceneData.length === 0) { 
                    activeSceneIndex = -1; 
                    document.querySelectorAll('.scene-box.active-scene').forEach(box => box.classList.remove('active-scene'));
                    return;
                 }
                 index = Math.max(0, Math.min(index, sceneData.length - 1));
            }
            activeSceneIndex = index;
            document.querySelectorAll('.scene-box').forEach((box) => {
                if (parseInt(box.dataset.sceneIndex) === index) {
                    box.classList.add('active-scene');
                } else {
                    box.classList.remove('active-scene');
                }
            });
        }

        function handleChunkClick(text, spanElement) {
            if (activeSceneIndex < 0 || activeSceneIndex >= sceneData.length) {
                 showFeedback("Please add or select a scene first.", "error");
                 return;
            }

            const activeSceneObject = sceneData[activeSceneIndex];
            activeSceneObject.content += text.trim() + " ";
            
            const activeSceneBox = document.querySelector(`.scene-box[data-scene-id='${activeSceneObject.id}']`);
            if (activeSceneBox) {
                const targetTextarea = activeSceneBox.querySelector('textarea');
                if (targetTextarea) {
                    targetTextarea.value = activeSceneObject.content;
                }
            }
            
            if (spanElement.classList.contains('clicked-twice')) {
            } else if (spanElement.classList.contains('clicked-once')) {
                spanElement.classList.remove('clicked-once');
                spanElement.classList.add('clicked-twice');
            } else {
                 spanElement.classList.add('clicked-once');
            }
            setTimeout(() => {
                spanElement.classList.remove('clicked-once', 'clicked-twice');
            }, 1000);
        }

        function clearSpecificSceneText(sceneIdToClear, sceneVisualIndex) {
            const sceneIndexInArray = sceneData.findIndex(s => s.id === sceneIdToClear);
            if (sceneIndexInArray === -1) {
                showFeedback("Could not find scene to clear.", "error");
                return;
            }
            sceneData[sceneIndexInArray].content = ""; 

            const sceneBox = document.querySelector(`.scene-box[data-scene-id='${sceneIdToClear}']`);
            if (sceneBox) {
                const targetTextarea = sceneBox.querySelector('textarea');
                if (targetTextarea) {
                    targetTextarea.value = "";
                    showFeedback(`Text cleared from Scene ${sceneVisualIndex + 1}.`, "success");
                }
            }
        }

        function copySpecificSceneText(sceneIdToCopy, sceneVisualIndex) {
            const sceneIndexInArray = sceneData.findIndex(s => s.id === sceneIdToCopy);
            if (sceneIndexInArray === -1) {
                showFeedback("Could not find scene to copy.", "error");
                return;
            }
            const textToCopy = sceneData[sceneIndexInArray].content;

            if (textToCopy.trim() === "") {
                showFeedback(`Scene ${sceneVisualIndex + 1} is empty. Nothing to copy.`, "info");
                return;
            }

            const tempTextarea = document.createElement('textarea');
            tempTextarea.value = textToCopy;
            document.body.appendChild(tempTextarea);
            tempTextarea.select();
            try {
                document.execCommand('copy');
                showFeedback(`Text from Scene ${sceneVisualIndex + 1} copied to clipboard!`, "success");
            } catch (err) {
                console.error('Failed to copy scene text: ', err);
                showFeedback("Failed to copy scene text. See console.", "error");
            }
            document.body.removeChild(tempTextarea);
        }
        

        async function saveScript() {
            if (!userId) {
                showFeedback("You must be signed in to save.", "error");
                return;
            }
            const scenesToSave = sceneData.map(s => s.content);

            try {
                const scriptRef = doc(db, `artifacts/${appId}/users/${userId}/vidsScripts/particleTheoryScript`);
                await setDoc(scriptRef, {
                    scenes: scenesToSave, 
                    title: "Particle Theory Script", 
                    lastSaved: serverTimestamp()
                });
                showFeedback("Script saved successfully!", "success");
            } catch (error) {
                console.error("Error saving script:", error);
                showFeedback("Error saving script. See console for details.", "error");
            }
        }

        async function loadScript() {
            if (!userId) {
                showFeedback("You must be signed in to load.", "error");
                if (sceneData.length === 0) addNewScene();
                return;
            }
            try {
                const scriptRef = doc(db, `artifacts/${appId}/users/${userId}/vidsScripts/particleTheoryScript`);
                const docSnap = await getDoc(scriptRef);

                if (docSnap.exists()) {
                    const scriptDataFromDb = docSnap.data();
                    const scenesFromDb = Array.isArray(scriptDataFromDb.scenes) ? scriptDataFromDb.scenes : [];
                    sceneData = scenesFromDb.map(content => ({ id: generateUniqueId(), content: content }));
                    
                    if (sceneData.length > 0) {
                         setActiveScene(0); 
                    } else {
                        addNewScene(); 
                    }
                    renderAllScenes(); 
                    showFeedback("Script loaded successfully!", "success");
                } else {
                    showFeedback("No saved script found. Starting fresh.", "info");
                    sceneData = []; 
                    addNewScene(); 
                }
            } catch (error) {
                console.error("Error loading script:", error);
                showFeedback("Error loading script. See console for details.", "error");
                if (sceneData.length === 0) addNewScene(); 
            }
        }

        function copyFullScriptToClipboard() { 
            let fullScriptText = "";
            sceneData.forEach((sceneObj, index) => {
                fullScriptText += `Scene ${index + 1}:\n${sceneObj.content}\n\n`;
            });

            if (fullScriptText.trim() === "") {
                showFeedback("Nothing to copy. Add some content to your scenes.", "info");
                return;
            }

            const tempTextarea = document.createElement('textarea');
            tempTextarea.value = fullScriptText.trim();
            document.body.appendChild(tempTextarea);
            tempTextarea.select();
            try {
                document.execCommand('copy');
                showFeedback("Full script copied to clipboard!", "success");
            } catch (err) {
                console.error('Failed to copy full script: ', err);
                showFeedback("Failed to copy full script. See console for details.", "error");
            }
            document.body.removeChild(tempTextarea);
        }

        function showFeedback(message, type = "info") {
            feedbackArea.textContent = message;
            feedbackArea.className = 'feedback '; 
            if (type === "success") {
                feedbackArea.style.color = "#16a34a"; 
            } else if (type === "error") {
                feedbackArea.style.color = "#dc2626"; 
            } else { 
                feedbackArea.style.color = "#525252"; 
            }
            setTimeout(() => { feedbackArea.textContent = ''; }, 3000);
        }
        
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                console.log("User signed in with UID:", userId);
                await loadScript(); 
            } else {
                userId = null;
                console.log("User is signed out or auth state not yet determined.");
                if (typeof __initial_auth_token === 'undefined' || !__initial_auth_token) {
                    console.log("Attempting anonymous sign-in...");
                    try {
                        await signInAnonymously(auth);
                    } catch (error) {
                        console.error("Anonymous sign-in failed:", error);
                        showFeedback("Could not initialize user session.", "error");
                        if (sceneData.length === 0) addNewScene();
                    }
                } else {
                    console.log("Waiting for custom token sign-in (onAuthStateChanged)...");
                }
            }
        });

        async function attemptCustomTokenSignIn() {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token && !auth.currentUser) {
                try {
                    console.log("Attempting sign-in with custom token (attemptCustomTokenSignIn)...");
                    await signInWithCustomToken(auth, __initial_auth_token);
                } catch (error) {
                    console.error("Custom token sign-in failed (attemptCustomTokenSignIn):", error);
                    showFeedback("Authentication failed. Trying anonymous.", "error");
                    if (!auth.currentUser) {
                         console.log("Custom token failed, attempting anonymous sign-in as fallback (attemptCustomTokenSignIn)...");
                        try {
                            await signInAnonymously(auth);
                        } catch (anonError) {
                            console.error("Anonymous sign-in failed after custom token failure (attemptCustomTokenSignIn):", anonError);
                            if (sceneData.length === 0) addNewScene(); 
                        }
                    }
                }
            }
        }

        renderSourceText();
        addSceneBtn.addEventListener('click', addNewScene);
        saveScriptBtn.addEventListener('click', saveScript);
        copyScriptBtn.addEventListener('click', copyFullScriptToClipboard); 
        loadScriptBtn.addEventListener('click', loadScript);

        attemptCustomTokenSignIn().finally(() => {
            if (sceneData.length === 0) { 
                 console.log("Final check after auth attempts: No scenes loaded or created, adding initial scene if still none.");
                 if (sceneData.length === 0) { 
                    addNewScene();
                 }
            }
        });

    </script>
</body>
</html>
